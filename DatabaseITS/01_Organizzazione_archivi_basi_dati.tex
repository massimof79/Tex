\documentclass[aspectratio=169,xcolor={dvipsnames}]{beamer}
\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning,shadows}
\usepackage{amssymb}   % per simboli matematici e \checkmark
\usepackage{pifont}    % per \ding{51} / \ding{55}
\usepackage{eurosym}   % per \euro
\usepackage{tikz}



% Tema beamer
\usetheme{Madrid}
\usecolortheme{default}

% Colori personalizzati
\definecolor{darkblue}{RGB}{0,51,102}
\setbeamercolor{structure}{fg=darkblue}
\setbeamercolor{title}{fg=white,bg=darkblue}
\setbeamercolor{frametitle}{fg=white,bg=darkblue}

% Informazioni documento
\title{L'organizzazione degli archivi e le basi di dati}
\subtitle{ITS Academy - Fabbrica digitale 4.0}
\author{Docente: Fedeli Massimo}
\date{AS 2025/26}
\institute{Tutti i diritti riservati}

\begin{document}

% Titolo
\begin{frame}
\titlepage
\end{frame}



\section{Gli archivi}
\begin{frame}
\begin{center}
	{\LARGE \textbf{Gli archivi}}
\end{center}
\end{frame}
% ========== GLI ARCHIVI ==========
\begin{frame}{Gli Archivi}
	\begin{columns}[T]
		\begin{column}{0.55\textwidth}
			\textbf{Definizione}
			
			Un \alert{archivio} è una collezione organizzata di dati correlati, memorizzati in modo permanente su supporti di memoria di massa.
			
			\vspace{0.3cm}
			\textbf{Analogia}
			Analogamente a uno schedario fisico, contiene informazioni strutturate e facilmente accessibili.
			\vspace{0.3cm}
			
			\textbf{Elementi fondamentali}
			\begin{itemize}
				\item \textbf{Record}: unità di informazione
				\item \textbf{Campi}: attributi descrittivi
				\item \textbf{Supporto}: dispositivo di memoria di massa
				\item \textbf{Organizzazione}: modalità di strutturazione dei dati
			\end{itemize}
		\end{column}
		
		\begin{column}{0.4\textwidth}
			\begin{tikzpicture}[scale=0.8, every node/.style={font=\small}]
				% Archivio fisico
				\draw[fill=gray!20] (0,4) rectangle (3,5.5);
				\draw (1.5,5.8) node {\textbf{Archivio fisico}};
				\foreach \y in {4.2,4.6,5.0} {
					\draw[fill=white] (0.2,\y) rectangle (2.8,\y+0.3);
				}
				
				% Freccia
				\draw[->,thick] (1.5,3.8) -- (1.5,3.2);
				
				% Archivio digitale
				\draw[fill=blue!20] (0,0.5) rectangle (3,3);
				\draw (1.5,3.3) node {\textbf{Archivio digitale}};
				
				% Record
				\draw[fill=green!30] (0.3,2.3) rectangle (2.7,2.8);
				\draw (1.5,2.55) node {\scriptsize Record 1};
				
				\draw[fill=green!30] (0.3,1.6) rectangle (2.7,2.1);
				\draw (1.5,1.85) node {\scriptsize Record 2};
				
				\draw[fill=green!30] (0.3,0.9) rectangle (2.7,1.4);
				\draw (1.5,1.15) node {\scriptsize Record 3};
				
				% Campi (nel primo record)
				\draw[dashed] (0.3,2.55) -- (2.7,2.55);
			\end{tikzpicture}
		\end{column}
	\end{columns}
\end{frame}

 
\begin{frame}{Gli archivi}
\begin{itemize}
\item L'uso degli archivi deriva dalla necessità di conservare dati e informazioni in modo permanente perché potranno essere utili in momenti successivi.
\end{itemize}

\textbf{Quali dati necessitano di essere memorizzati?}
\begin{itemize}
\item Questo vale per dati di tipo personale, come quelli contenuti in una normale rubrica di contatti, ma anche per i documenti funzionali alla vita di uno Stato, di un'azienda o di un ente.
\end{itemize}

\textbf{Chi ne ha bisogno?}
\begin{itemize}
\item In un'\textbf{azienda }l'esecuzione delle normali attività amministrative e operative, così come la definizione e la scelta delle politiche commerciali, finanziarie e relative al personale, è strettamente legata all'elaborazione di insiemi di dati che sono raccolti e conservati in archivi.
\end{itemize}
\end{frame}


% ========== DEFINIZIONE DI ARCHIVIO ==========
\begin{frame}{Definizione di archivio}
\textbf{Def.} un archivio può essere definito come un \textbf{insieme organizzato di informazioni} caratterizzate da alcune proprietà fondamentali:


\begin{itemize}
\item esiste un \textbf{nesso logico} tra di esse (cioè sono in qualche modo inerenti a un medesimo argomento);
\item sono rappresentate secondo un \textbf{formato} che ne rende possibile l'interpretazione;
\item sono registrate con un supporto su cui è possibile scrivere e rileggere informazioni anche a distanza di tempo;
\item sono organizzate in modo che siano \textbf{facilmente consultabili}.
\end{itemize}
\end{frame}

\begin{frame}{Correlazione tra dati - esempio dell'archivio telefonico}
	\begin{itemize}
\item L'\textbf{elenco telefonico} è un archivio di dati in cui le informazioni riguardano gli abbonati al telefono di una provincia.

\item Per ogni abbonato sono riportati nell'ordine: 
	generalità
	indirizzo
	numero di telefono\begin{figure}
		\centering
		\includegraphics[width=0.3\linewidth]{db}
		\caption{}
		\label{fig:db}
	\end{figure}
	
	tutte queste informazioni sono stampate su fogli di carta oppure sono accessibili tramite Internet.

\item Le informazioni vengono raccolte in questo archivio perché si riferiscono agli abbonati di una stessa provincia e, all'interno della provincia, di uno stesso comune \textbf{(nesso logico).}
		 
	\end{itemize}
	
	
\end{frame}

\begin{frame}{Gli archivi}
\begin{itemize}
\item La struttura delle informazioni nelle \textbf{righe} (formato), ne rende facile la lettura e l'interpretazione da parte della persona che consulta l'elenco.
\item Il supporto è dal disco che contiene i dati.
\item Gli abbonati sono stampati seguendo l'ordine alfabetico dei cognomi, all'interno della suddivisione per comune, per permettere un veloce reperimento del numero di telefono che corrisponde alla persona cercata (organizzazione dei dati).
\end{itemize}
\end{frame}

\begin{frame}
\begin{figure}
	\centering
	\includegraphics[width=0.6\linewidth]{archivi}
	\caption{Gestione automatizzata degli archivi}
	\label{fig:archivi}
\end{figure}

\end{frame}


% ========== RECORD E CAMPI ==========
\subsection{Record e campi}
\begin{frame}
	\begin{center}
		{\LARGE \textbf{I record e i campi}}
	\end{center}
\end{frame}

\begin{frame}{I record e i campi}
	In un archivio le informazioni, in genere, sono raggruppate secondo un'\textbf{unità logica}: nel caso dell'elenco telefonico i dati relativi a ogni abbonato, in un archivio notarile i dati contenuti nell'incartamento relativo a un cliente.
\vspace{0.5cm}
	Questi insiemi di informazioni logicamente organizzate e riferite a un unico soggetto sono chiamati con il termine \textbf{record};
\begin{itemize}
\item Le singole informazioni che compongono il record si chiamano \textbf{campi};
\item L'elenco dei campi che lo compongono viene detto \textbf{tracciato del record}.
\end{itemize}
\end{frame}

\begin{frame}

\begin{figure}
	\centering
	\includegraphics[width=0.6\linewidth]{record}
	\caption{Record}
	\label{fig:record}
\end{figure}

\end{frame}

% ========== FILE ==========
\begin{frame}{File}
Si consideri un archivio con le informazioni anagrafiche degli studenti.

\begin{itemize}
\item Una determinata collezione di record omogenei è detto \textbf{file}.
\item Un \textbf{archivio} si compone solitamente di più file.
\item Ogni record del file contiene le informazioni anagrafiche di un dato studente ed è composto da un insieme di campi.
\item Nel caso di un archivio anagrafico il record sarà composto, per esempio, da campi per rappresentare il \underline{numero di matricola, il cognome, il nome, la data e il luogo di nascita, l'indirizzo e il numero di telefono }dello studente descritto nel record.
\end{itemize}
\end{frame}

\begin{frame}{Il file - definizione}
	\begin{columns}[T]
		\begin{column}{0.5\textwidth}
			\begin{block}{Definizione}
				Un \textbf{file} è una collezione di record, cioè di informazioni logicamente omogenee che descrivono i singoli elementi di una realtà considerata.
			\end{block}
			
			\vspace{0.3cm}
			
			Ogni record è composto da un insieme di \alert{campi} che contengono i valori assunti dalle caratteristiche scelte per descrivere la realtà.
		\end{column}
		
		\begin{column}{0.45\textwidth}
			\begin{tikzpicture}[scale=0.85, every node/.style={font=\scriptsize}]
				% Titolo del file
				\draw[fill=orange!30, rounded corners] (-0.2,4.5) rectangle (4.2,5) node[pos=.5] {\textbf{FILE: Studenti.dat}};
				
				% Header con nomi dei campi
				\draw[fill=blue!40] (0,3.8) rectangle (1.3,4.3);
				\draw (0.65,4.05) node {\textbf{ID}};
				
				\draw[fill=blue!40] (1.4,3.8) rectangle (2.7,4.3);
				\draw (2.05,4.05) node {\textbf{Nome}};
				
				\draw[fill=blue!40] (2.8,3.8) rectangle (4,4.3);
				\draw (3.4,4.05) node {\textbf{Classe}};
				
				% Record 1
				\draw[fill=green!20] (0,3.1) rectangle (1.3,3.6);
				\draw (0.65,3.35) node {001};
				
				\draw[fill=green!20] (1.4,3.1) rectangle (2.7,3.6);
				\draw (2.05,3.35) node {Mario};
				
				\draw[fill=green!20] (2.8,3.1) rectangle (4,3.6);
				\draw (3.4,3.35) node {5A};
				
				\draw[<-, thick, red] (4.2,3.35) -- (4.8,3.35) node[right] {\textcolor{red}{Record 1}};
				
				% Record 2
				\draw[fill=green!20] (0,2.4) rectangle (1.3,2.9);
				\draw (0.65,2.65) node {002};
				
				\draw[fill=green!20] (1.4,2.4) rectangle (2.7,2.9);
				\draw (2.05,2.65) node {Laura};
				
				\draw[fill=green!20] (2.8,2.4) rectangle (4,2.9);
				\draw (3.4,2.65) node {4B};
				
				\draw[<-, thick, red] (4.2,2.65) -- (4.8,2.65) node[right] {\textcolor{red}{Record 2}};
				
				% Record 3
				\draw[fill=green!20] (0,1.7) rectangle (1.3,2.2);
				\draw (0.65,1.95) node {003};
				
				\draw[fill=green!20] (1.4,1.7) rectangle (2.7,2.2);
				\draw (2.05,1.95) node {Giulia};
				
				\draw[fill=green!20] (2.8,1.7) rectangle (4,2.2);
				\draw (3.4,1.95) node {5A};
				
				\draw[<-, thick, red] (4.2,1.95) -- (4.8,1.95) node[right] {\textcolor{red}{Record 3}};
				
				% Indicazione campi
				\draw[<-, thick, blue] (0.65,3.8) -- (0.65,4.8) node[above] {\textcolor{blue}{Campo}};
				
				% Puntini per indicare altri record
				\draw (2,1.3) node {$\vdots$};
			\end{tikzpicture}
		\end{column}
	\end{columns}
\end{frame}

% ========== CREAZIONE DI UN ARCHIVIO ==========
\begin{frame}{La creazione di un archivio}
La creazione di un archivio richiede la definizione preliminare delle seguenti specifiche:

\begin{itemize}
\item il \textbf{nome dell'archivio}, che lo identifica e serve a ricordarne il contenuto; per esempio ``archivio fornitori'' oppure ``archivio anagrafico'';
\item il \textbf{tracciato record}, in altre parole quali informazioni compongono il record;
\item il \textbf{supporto} da usare per archiviare i dati (fogli di carta, dischi o nastri magnetici, dischi ottici);
\item la \textbf{dimensione massima} dell'archivio: per esempio il numero massimo di scaffali occupati in un archivio cartaceo o di abbonati in un elenco telefonico;
\item il modo con cui i dati sono strutturati e collegati tra loro, cioè l'\textbf{organizzazione dell'archivio}\textbf{(Legami tra le tabelle)}
\end{itemize}
\end{frame}

\begin{frame}{Legami tra tabelle}
\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{relazioni}
	\caption[Legami tra tabelle]{Legami tra tabelle}
	\label{fig:relazioni}
\end{figure}

\end{frame}

\begin{frame}{Interrogazione e modifica dei dati}
	\begin{columns}[T]
		\begin{column}{0.5\textwidth}
			Dopo aver creato l'archivio, su di esso si possono effettuare operazioni di:
			\begin{itemize}
				\item \textbf{manipolazione}, cioè inserimento di nuovi dati o variazione dei dati registrati;
				\item \textbf{interrogazione}, cioè reperimento all'interno dell'archivio delle informazioni necessarie.
			\end{itemize}
		\end{column}
		
		\begin{column}{0.45\textwidth}
			\begin{tikzpicture}[scale=0.9, every node/.style={font=\small}]
				% Database centrale
				\draw[fill=blue!20, rounded corners] (2,2.5) circle (1.2cm);
				\draw (2,2.5) node[align=center] {\textbf{ARCHIVIO}\\\textbf{DATI}};
				
				% Operazioni di MANIPOLAZIONE (a sinistra)
				\draw[fill=green!30, rounded corners] (-0.5,4.5) rectangle (1.5,5.2);
				\draw (0.5,4.85) node {\textbf{INSERT}};
				\draw[->, thick, green!70!black] (0.8,4.5) -- (1.3,3.4);
				
				\draw[fill=orange!30, rounded corners] (-0.5,3.3) rectangle (1.5,4);
				\draw (0.5,3.65) node {\textbf{UPDATE}};
				\draw[->, thick, orange!70!black] (0.8,3.3) -- (1.2,2.9);
				
				\draw[fill=red!30, rounded corners] (-0.5,2.1) rectangle (1.5,2.8);
				\draw (0.5,2.45) node {\textbf{DELETE}};
				\draw[->, thick, red!70!black] (0.8,2.5) -- (1.2,2.5);
				
				% Etichetta MANIPOLAZIONE
				\draw[fill=green!10, rounded corners] (-0.7,1.3) rectangle (1.7,1.8);
				\draw (0.5,1.55) node[font=\scriptsize\bfseries] {MANIPOLAZIONE};
				
				% Operazione di INTERROGAZIONE (a destra)
				\draw[fill=cyan!30, rounded corners] (2.5,4.5) rectangle (4.5,5.2);
				\draw (3.5,4.85) node {\textbf{SELECT}};
				\draw[<-, thick, cyan!70!black] (3.2,4.5) -- (2.7,3.4);
				
				% Risultato query
				\draw[fill=cyan!10, rounded corners, dashed] (2.5,0.3) rectangle (4.5,1.5);
				\draw (3.5,1.2) node[font=\scriptsize] {ID: 001};
				\draw (3.5,0.9) node[font=\scriptsize] {Nome: Mario};
				\draw (3.5,0.6) node[font=\scriptsize] {Classe: 5A};
				\draw[<-, thick, cyan!70!black] (3.5,1.5) -- (2.7,1.9);
				
				% Etichetta INTERROGAZIONE
				\draw[fill=cyan!10, rounded corners] (2.3,0) rectangle (4.7,0.2);
				\draw (3.5,0.1) node[font=\tiny\bfseries] {INTERROGAZIONE};
				
			\end{tikzpicture}
		\end{column}
	\end{columns}
\end{frame}

% ========== FILE E MEMORIE DI MASSA ==========

\begin{frame}{File e Memorie di Massa}
	\begin{center}
		\begin{tikzpicture}[scale=1.1, every node/.style={font=\small}]
			
			% RAM (memoria volatile) - in alto
			\draw[fill=red!20, rounded corners, drop shadow] (0,6) rectangle (3,7.5);
			\draw (1.5,7.2) node[font=\bfseries] {RAM};
			\draw (1.5,6.7) node[font=\scriptsize] {Memoria};
			\draw (1.5,6.4) node[font=\scriptsize] {Volatile};
			\draw (3.3,6.75) node[font=\tiny] {veloce};
			
			% CPU
			\draw[fill=gray!30, rounded corners] (-2,6.3) rectangle (-0.5,7.2);
			\draw (-1.25,6.75) node[font=\bfseries] {CPU};
			
			% Frecce CPU <-> RAM
			\draw[->, thick, blue] (-0.5,6.9) -- (0,6.9);
			\draw[<-, thick, blue] (-0.5,6.6) -- (0,6.6);
			
			% Freccia grande verso il basso (salvataggio permanente)
			\draw[->, ultra thick, green!60!black] (1.5,6) -- (1.5,4.8);
			\draw (2.5,5.4) node[font=\scriptsize, align=left] {\textcolor{green!60!black}{\textbf{Salvataggio}}\\[-2pt]\textcolor{green!60!black}{\textbf{permanente}}};
			
			% Freccia grande verso l'alto (caricamento)
			\draw[->, ultra thick, orange!80!black] (4.5,4.8) -- (4.5,6);
			\draw (5.5,5.4) node[font=\scriptsize, align=left] {\textcolor{orange!80!black}{\textbf{Caricamento}}\\[-2pt]\textcolor{orange!80!black}{\textbf{in memoria}}};
			
			% Memoria di massa (Hard Disk)
			\draw[fill=blue!30, rounded corners, drop shadow] (-1,2.5) rectangle (2,4.5);
			\draw[fill=gray!50] (0.5,3.5) circle (0.8cm);
			\draw[fill=white] (0.5,3.5) circle (0.2cm);
			\draw (0.5,2.9) node[font=\bfseries] {Hard Disk};
			\draw (0.5,2.6) node[font=\tiny] {lento};
			
			% Memoria di massa (SSD)
			\draw[fill=purple!30, rounded corners, drop shadow] (2.5,2.5) rectangle (5.5,4.5);
			\draw[fill=gray!40, rounded corners] (3.2,3) rectangle (4.8,4);
			\foreach \x in {3.4,3.7,4.0,4.3,4.6} {
				\draw[fill=yellow!50] (\x,3.2) rectangle (\x+0.2,3.8);
			}
			\draw (4,2.9) node[font=\bfseries] {SSD};
			\draw (4,2.6) node[font=\tiny] {veloce};
			
			% Memoria di massa (USB/Cloud)
			\draw[fill=green!30, rounded corners, drop shadow] (6,2.5) rectangle (9,4.5);
			\draw[fill=gray!60, rounded corners] (7,3.2) rectangle (8,3.8);
			\draw (7.5,3.5) node[font=\tiny\bfseries] {USB};
			\draw (7.5,2.9) node[font=\bfseries] {Dispositivi};
			\draw (7.5,2.6) node[font=\scriptsize] {rimovibili};
			
			% File rappresentati su memoria di massa
			\draw[fill=yellow!40, rounded corners] (-0.5,1.2) rectangle (0.7,1.8);
			\draw (0.1,1.5) node[font=\tiny] {doc.txt};
			
			\draw[fill=yellow!40, rounded corners] (1,1.2) rectangle (2.2,1.8);
			\draw (1.6,1.5) node[font=\tiny] {foto.jpg};
			
			\draw[fill=yellow!40, rounded corners] (2.8,1.2) rectangle (4,1.8);
			\draw (3.4,1.5) node[font=\tiny] {video.mp4};
			
			\draw[fill=yellow!40, rounded corners] (4.5,1.2) rectangle (5.7,1.8);
			\draw (5.1,1.5) node[font=\tiny] {dati.db};
			
			\draw[fill=yellow!40, rounded corners] (6.2,1.2) rectangle (7.4,1.8);
			\draw (6.8,1.5) node[font=\tiny] {prog.exe};
			
			% Etichetta FILE
			\draw (3.8,0.7) node[font=\bfseries\large] {FILE memorizzati permanentemente};
			
			% Box esplicativo
			\draw[fill=yellow!10, rounded corners, dashed] (9.5,3) rectangle (12.5,7);
			\draw (11,6.6) node[font=\scriptsize\bfseries] {Caratteristiche:};
			\draw (11,6.1) node[font=\tiny, align=left] {
				$\bullet$~Persistenza dati\\
				$\bullet$~Accesso sequenziale\\
				$\bullet$~o diretto\\
				$\bullet$~Organizzazione\\
				$\bullet$~strutturata\\
				$\bullet$~Capacità elevata
			};
			
			\draw (11,3.5) node[font=\scriptsize\bfseries, align=center] {Memorie\\di Massa};
			
		\end{tikzpicture}
	\end{center}
\end{frame}

\begin{frame}{I file e le memorie di massa}
	\begin{itemize}
\item Gli archivi memorizzati su tali supporti vengono detti \textbf{file} perchè in inglese la parola archivio viene tradotta con file.
\item  In informatica questo termine serve a indicare in modo generico qualsiasi informazione che può essere registrata sui supporti di memoria, come un testo, un programma, un comando del sistema operativo o un grafico.
	\item Nelle \textbf{applicazioni} con il computer, un archivio può contenere qualsiasi tipo di informazione, non solo di tipo testuale ma anche di tipo multimediale.
			\item Nelle procedure gestionali comunque, nella maggior parte dei casi, gli archivi sono costituiti da insiemi di record omogenei, nel senso che ciascun archivio possiede un tracciato predefinito e uguale per tutti i record in esso contenuti, che si dicono \textbf{record logici} (file di record).
	\end{itemize}

\end{frame}



\begin{frame}{I file e le memorie di massa}
	\begin{itemize}
		\item I supporti per registrare i dati prendono il nome di \textbf{memorie di massa} perché possono contenere notevoli quantità di dati.
		\item Si chiamano anche \textbf{memorie ausiliarie}, perché costituiscono un'estensione della memoria centrale di un computer e consentono, a differenza della memoria centrale che è una memoria volatile, la permanenza delle registrazioni nel tempo.
		\item Tali apparecchiature sono esterne all'unità centrale e quindi sono \textbf{unità periferiche di memoria} (o semplicemente periferiche).
			
	\end{itemize}


\end{frame}

\begin{frame}{Le memorie di massa}
Le memorie di massa sono caratterizzate da alcuni parametri usati abitualmente per illustrarne le prestazioni:

\begin{itemize}
\item il \textbf{tipo di accesso ai dati}, che può essere diretto (o random) come nei dischi oppure sequenziale come nei nastri;
\item la \textbf{capacità}, in pratica la quantità di dati che il supporto è in grado di contenere; si misura in Megabyte, Gigabyte e Terabyte;
\item il \textbf{tempo medio di accesso} misurato in millisecondi (ms), costituito dal tempo medio necessario per ritrovare i dati e per trasferirli nell'unità centrale;
\item la \textbf{velocità di trasferimento} dei dati dalla memoria di massa alla memoria centrale misurata in KB/s o MB/s, in altre parole il numero di byte trasferiti dal supporto alla memoria del computer in un secondo.
\end{itemize}
\end{frame}

\begin{frame}{I file e le memorie di massa}
\begin{figure}
	\centering
	\includegraphics[width=0.5\linewidth]{memorie_massa}
	\caption{}
	\label{fig:memoriemassa}
\end{figure}

\end{frame}


% ========== IL FILESYSTEM ==========
\subsection{Il file system}
\begin{frame}
	\begin{center}
		{\LARGE \textbf{Il file system}}
	\end{center}
	\end{frame}
\begin{frame}{Il filesystem}
	\begin{itemize}
		\item Il modulo del sistema operativo che svolge le funzioni di gestore dei file viene chiamato \textbf{file system}.
		\item Esso è costituito dall'insieme delle routine (funzioni) che consentono all'utente-programmatore di usufruire degli archivi sulle memorie di massa, senza preoccuparsi dei dettagli delle operazioni di input/output (I/O) e facendo riferimento ai file solo con nomi simbolici.
\item Il file system regola l'organizzazione, l'assegnamento, la protezione e il ritrovamento di insiemi di dati, cioè di file. In particolare esso svolge le seguenti funzioni:
	\end{itemize}

\end{frame}


% ========== ORGANIZZAZIONE DEGLI ARCHIVI ==========
\section{Organizzazione degli archivi}
\begin{frame}
\begin{center}
{\LARGE \textbf{Organizzazione degli archivi}}
\end{center}
\end{frame}

% ========== ORGANIZZAZIONE SEQUENZIALE ==========
\subsection{Organizzazione sequenziale}
\begin{frame}
\begin{center}
{\Large \textbf{Organizzazione sequenziale}}
\end{center}
\end{frame}

\begin{frame}{L'organizzazione sequenziale}
	\begin{itemize}
		\item L'\textbf{organizzazione sequenziale} consiste nel registrare i record uno di seguito all'altro, in modo sequenziale, intervallati da sequenze di caratteri che indicano la fine del record.
		\item Essa consente l'uso di \textbf{record a lunghezza variabile} e ha come modello di file il pacco di schede o un file su nastro magnetico dove è possibile accedere a un record solo dopo aver visitato tutti i record che lo precedono.
		\item Si parla in tal caso di \textbf{accesso sequenziale}.
	\end{itemize}
\end{frame}

\begin{frame}
\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{accesso_sequenziale}
	\caption[Accesso sequenziale]{Accesso sequenziale}
	\label{fig:accessosequenziale}
\end{figure}

\end{frame}


\begin{frame}{L'organizzazione sequenziale}
	\begin{itemize}
		\item Questo tipo di organizzazione, semplice da gestire, consente l'uso di record aventi lunghezza diversa l'uno dall'altro.
		\item L'organizzazione sequenziale presenta dei \textbf{limiti} in fase di ritrovamento dei dati quando il numero dei record diventa elevato.
		\item Risulta invece un'organizzazione \textbf{efficace per file di piccole dimensioni}, per esempio file di testo, e che comunque possono essere pensati come un flusso di caratteri intervallati da sequenze di caratteri che indicano la fine del record.
	\end{itemize}
\end{frame}

\begin{frame}{L'organizzazione sequenziale}
	\begin{itemize}
		\item Un file a organizzazione sequenziale può essere utilizzato solo per \textbf{scrivere nuovi record}, per\textbf{ leggere record }o per aggiungere record in coda a quelli già registrati.
		\item La scrittura di record a partire da una qualsiasi posizione, eseguita su un file già esistente, provoca di norma la cancellazione di tutti i record che lo seguono; perciò la riscrittura dei record non è permessa.
	\end{itemize}

\end{frame}

% ========== ORGANIZZAZIONE AD ACCESSO DIRETTO ==========
\subsection{Organizzazione ad accesso diretto}
\begin{frame}
\begin{center}
{\Large \textbf{Organizzazione ad accesso diretto}}
\end{center}
\end{frame}

\begin{frame}
\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{accesso_diretto}
	\caption[File ad accesso diretto]{}
	\label{fig:accessodiretto}
\end{figure}

\end{frame}

\begin{frame}{L'organizzazione ad accesso diretto}
\begin{itemize}
\item I file con \textit{record di lunghezza fiss}a, cioè aventi tutti la stessa lunghezza, sono di uso comune nelle applicazioni gestionali (record del cliente, record dell'articolo di magazzino, record anagrafico dello studente)
\item In questo caso si può calcolare la posizione del primo carattere di un qualsiasi record, nota la sua posizione nel file.
\end{itemize}
\end{frame}

% ========== ORGANIZZAZIONE AD INDICI ==========
\subsection{Organizzazione ad indici}



\begin{frame}
\begin{center}
{\Large \textbf{Organizzazione ad indici}}
\end{center}
\end{frame}

\begin{frame}{L'organizzazione ad indici (accesso associativo)}

Nelle applicazioni gestionali non basta poter accedere a un record mediante la posizione che occupa in un file, ma bisogna riuscire a identificare un record in base a informazioni contenute nel record stesso (\textbf{accesso associativo}).

\end{frame}


\begin{frame}
	\begin{figure}
		\centering
		\includegraphics[width=0.7\linewidth]{indice}
		\caption[Organizzazione ad indice]{Organizzazione ad indice}
		\label{fig:indice}
	\end{figure}
	
\end{frame}


\begin{frame}{Esempio Pratico: Archivio Clienti}
Immagina di avere un database di 10.000 clienti.
Vuoi recuperare i dati di Giovanni Bianchi, ma non sai in quale posizione si trova il suo record nell'archivio.

\textbf{Come Funziona l'Accesso Associativo?}
\begin{itemize}
\item \textbf{Indice Creato}: Un sistema crea un ``indice'' che associa ogni nome cliente alla posizione del suo record.
\item \textbf{Ricerca Diretta}: Inserisci ``Giovanni Bianchi'', l'indice ti restituisce istantaneamente la posizione 892.
\item Il sistema accede direttamente al record senza scorrere tutto l'archivio.
\end{itemize}

Anche se devi ``consultare'' l'indice, lo fai su un dataset molto più piccolo e con una struttura ottimizzata per la ricerca. Questo trasforma un'operazione lenta (scansione completa) in una quasi istantanea.
\end{frame}

\begin{frame}{L'organizzazione ad indici}
\begin{itemize}
\item L'\textbf{accesso associativo }si ottiene usando file ad accesso diretto e metodi per calcolare la posizione occupata dal record che contiene le informazioni cercate.
\item Negli archivi con organizzazione ad indice i record sono identificati attraverso un elemento caratteristico (\textbf{chiave}) che di norma è una variabile alfanumerica, per esempio la matricola del dipendente di un'azienda, il codice di un articolo, il codice del cliente.
\end{itemize}
\end{frame}

\begin{frame}{L'organizzazione ad indici}
\textbf{1. La chiave (il ``nome''):}

Ogni record (foglio) ha un elemento unico:
\begin{itemize}
\item Matricola del dipendente (ID123)
\item Codice articolo (ART456)
\item Codice cliente (CLI789)
\end{itemize}

\textbf{2. L'indice (l'``indirizzario''):}

Il computer crea una tabella che associa ogni chiave alla posizione del record.

\textbf{3. La ricerca:}

Quando chiedi ``trovami il cliente CLI789'':
\begin{itemize}
\item Il computer guarda l'indice → trova ``CLI789 → Posizione 300''.
\item Salta direttamente al record 300 → nessuna scansione totale!
\end{itemize}
\end{frame}

\begin{frame}{L'organizzazione ad indici}
\begin{itemize}
\item Organizzazione ad indici implica la possibilità di leggere e scrivere record in base al valore della chiave identifica l'\textbf{accesso a chiave}.
\item I clienti sono identificati in modo univoco per mezzo di un codice e i record sono ordinati secondo l'ordine di arrivo in archivio.
		\item Per permettere l'\textbf{accesso a chiave} l'organizzazione dell'archivio deve essere simile a quella di un libro dotato di indice analitico: in tale indice sono elencate in ordine alfabetico le parole chiave, che richiamano gli argomenti e i concetti trattati nel testo, affiancate dalla pagina corrispondente del libro.
\item Il lettore cerca la parola nell'indice analitico secondo un metodo di \textbf{ricerca binaria} (o ricerca dicotomica): essendo l'elenco ordinato, il numero di pagina funziona da puntatore della pagina dove viene trattato l'argomento.

\item Basta allora costruire un \textbf{indice ordinato }in base al valore della chiave e abbinare a ogni valore del codice un puntatore al record posto in un file ad accesso diretto.

\end{itemize}
\end{frame}

\begin{frame}{L'organizzazione ad indici}
	\begin{itemize}
		\item In un file con \textbf{organizzazione sequenziale a indici}, accanto alla zona con i record, memorizzati in un file ad accesso diretto, è gestita una tabella delle chiavi o \textbf{file indice} con l'elenco ordinato delle chiavi.
		\item La ricerca di un record avviene con una ricerca binaria nella tabella delle chiavi per recuperare la posizione del record cercato nel file ad accesso diretto.
		\item In questo modo si riesce ad accedere al record specificandone il valore della chiave (accesso a chiave).
	\end{itemize}
\end{frame}

\begin{frame}
\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{indice_chiave}
	\caption[Costruzione dell'indice - chiave primaria]{Costruzione dell'indice - Chiave primaria}
	\label{fig:indicechiave}
\end{figure}


\end{frame}

\begin{frame}{L'organizzazione ad indici}
È possibile costruire un \textbf{indice}:
\begin{itemize}
\item sia sul campo che identifica univocamente un record, detto \textbf{chiave primaria} (per esempio, il numero di matricola di un dipendente)
\item sia su altri campi anche non univoci (per esempio, il cognome del dipendente).
\end{itemize}

In questo caso, accanto all'indice della chiave primaria, devono essere costruiti gli indici per tutti gli altri campi chiave considerati, in modo da consentire l'accesso a un record sia tramite la chiave primaria, sia tramite il valore di altri campi.
\end{frame}

% ========== LE BASI DI DATI ==========
\section{Le basi di dati}
\begin{frame}
\begin{center}
{\LARGE \textbf{Le basi di dati}}
\end{center}
\end{frame}

\begin{frame}{Le basi di dati}
Con il termine \textbf{basi di dati} (o database) si indicano in informatica gli archivi di dati:
\begin{itemize}
\item organizzati in modo integrato
\item progettati con tecniche di modellazione dei dati
\item gestiti sulle memorie di massa dei computer utilizzando appositi software
\end{itemize}

con l'obiettivo di manipolare e trovare in modo efficiente i dati memorizzati, superando i limiti presenti nelle organizzazioni tradizionali degli archivi.
\end{frame}

\begin{frame}{Le basi di dati}
\begin{figure}
	\caption[Basi di dati]{Basi di dati}
	\label{fig:database}
		\includegraphics[width=0.7\linewidth]{database}
		\end{figure}

\end{frame}

\begin{frame}{Le basi di dati}
Quando si parla di \textbf{efficienza} e di \textbf{produttività} dell'organizzazione degli archivi si intende la possibilità di:

\begin{itemize}
\item \textbf{ritrovare} facilmente le informazioni desiderate, anche con diversi criteri di ricerca e per scopi diversi;
\item gestire i dati con una buona \textbf{velocità di elaborazione};
\item garantire la \textbf{sicurezza dei dati e l'integrità} delle registrazioni.
\end{itemize}

Tutto questo diventa rilevante quando la gestione si riferisce a una mole considerevole di dati.

Devono anche essere offerte misure di sicurezza per impedire che il database venga danneggiato da interventi accidentali o non autorizzati, garantendo l'integrità dei dati e la consistenza del database.
\end{frame}

\begin{frame}{Le basi di dati}
\begin{itemize}
\item \textbf{Integrità} significa garantire che le operazioni effettuate sul database da utenti autorizzati non provochino una perdita di consistenza ai dati.
\item \textbf{Consistenza} degli archivi significa assicurare che i dati in essi contenuti siano significativi e siano effettivamente utilizzabili nelle applicazioni.
\end{itemize}
\end{frame}

\begin{frame}{Le basi di dati}
	\begin{columns}[T]
		\begin{column}{0.48\textwidth}
			\begin{itemize}
				\item I database favoriscono gli utenti nel manipolare i dati e liberandolo dagli aspetti riguardanti la collocazione fisica delle registrazioni sui supporti degli archivi.
				\item Viene così superata la visione tradizionale dell'organizzazione degli archivi basata su file che obbliga il programmatore ad accedere ai dati con comandi espliciti di apertura, chiusura, lettura, scrittura e posizionamento sui file contenenti i dati degli archivi da gestire.
			\end{itemize}
		\end{column}
		
		\begin{column}{0.48\textwidth}
			\begin{tikzpicture}[scale=0.75, every node/.style={font=\scriptsize}]
				
				% APPROCCIO TRADIZIONALE (File System)
				\draw[fill=red!10, rounded corners] (-0.5,5.5) rectangle (5,8.5);
				\draw (2.25,8.2) node[font=\small\bfseries] {APPROCCIO TRADIZIONALE};
				
				% Programmatore
				\draw[fill=orange!30, rounded corners] (0.5,6.8) rectangle (2,7.5);
				\draw (1.25,7.15) node[font=\tiny\bfseries] {Programmatore};
				
				% Comandi espliciti
				\draw[->, thick, red] (2,7.15) -- (3,7.15);
				\draw (2.5,7.4) node[font=\tiny, align=center] {open()\\read()\\write()\\close()};
				
				% File fisici
				\draw[fill=yellow!40, rounded corners] (3.2,7.5) rectangle (4,7.8);
				\draw (3.6,7.65) node[font=\tiny] {file1.dat};
				
				\draw[fill=yellow!40, rounded corners] (3.2,7.1) rectangle (4,7.4);
				\draw (3.6,7.25) node[font=\tiny] {file2.dat};
				
				\draw[fill=yellow!40, rounded corners] (3.2,6.7) rectangle (4,7.0);
				\draw (3.6,6.85) node[font=\tiny] {file3.dat};
				
				% Gestione fisica
				\draw[fill=gray!30, rounded corners] (0.5,6) rectangle (4,6.5);
				\draw (2.25,6.25) node[font=\tiny] {\textbf{Gestione fisica dei dati a carico del programmatore}};
				
				% Freccia verso il basso
				\draw[->, ultra thick] (2.25,5.3) -- (2.25,4.8);
				\draw (3.5,5.05) node[font=\tiny\bfseries, red] {SUPERAMENTO};
				
				% APPROCCIO DATABASE
				\draw[fill=green!10, rounded corners] (-0.5,0.2) rectangle (5,4.5);
				\draw (2.25,4.2) node[font=\small\bfseries] {APPROCCIO DATABASE};
				
				% Utente/Programmatore
				\draw[fill=blue!30, rounded corners] (0.5,3) rectangle (2,3.7);
				\draw (1.25,3.35) node[font=\tiny\bfseries] {Utente};
				
				% Query SQL semplici
				\draw[->, thick, green!60!black] (2,3.35) -- (3,3.35);
				\draw (2.5,3.6) node[font=\tiny, align=center] {SELECT\\INSERT\\UPDATE};
				
				% DBMS (livello intermedio)
				\draw[fill=purple!30, rounded corners, drop shadow] (3,2.5) rectangle (4.5,4);
				\draw (3.75,3.6) node[font=\tiny\bfseries, align=center] {DBMS};
				\draw (3.75,3.2) node[font=\tiny, align=center] {Gestisce\\accesso\\fisico};
				
				% Dati astratti
				\draw[fill=cyan!20, rounded corners] (0.5,1.8) rectangle (2,2.5);
				\draw (1.25,2.15) node[font=\tiny, align=center] {Astrazione\\dai dettagli\\fisici};
				
				% Database logico
				\draw[fill=green!40, rounded corners] (3,0.8) rectangle (4.5,2.2);
				\draw (3.75,1.8) node[font=\tiny\bfseries] {DATABASE};
				\draw (3.75,1.5) node[font=\tiny, align=center] {Organizzazione\\logica\\dei dati};
				
				% Vantaggi
				\draw[fill=yellow!20, rounded corners] (0.3,0.4) rectangle (4.7,0.7);
				\draw (2.5,0.55) node[font=\tiny] {\textbf{$\checkmark$ Indipendenza dai dettagli fisici}};
				
			\end{tikzpicture}
		\end{column}
	\end{columns}
\end{frame}


% ========== I DBMS ==========
\begin{frame}{I DBMS}
	\begin{columns}[T]
		\begin{column}{0.48\textwidth}
			I prodotti software per la gestione dei database sono indicati con il termine \textbf{DBMS}, acronimo di \textbf{DataBase Management System}.
			
			\vspace{0.3cm}
			
			I DBMS consentono all'utente di focalizzare l'attenzione solo sull'applicazione che utilizza i dati dell'archivio consentendone la gestione anche a utenti che nulla conoscono dell'hardware sottostante.
		\end{column}
		
		\begin{column}{0.48\textwidth}
			\begin{tikzpicture}[scale=0.85, every node/.style={font=\scriptsize}]
				
				% LIVELLO UTENTE/APPLICAZIONE
				\draw[fill=blue!20, rounded corners, drop shadow] (0,6.5) rectangle (5.5,7.8);
				\draw (2.75,7.4) node[font=\small\bfseries] {UTENTE / APPLICAZIONE};
				\draw (2.75,6.9) node[font=\tiny, align=center] {Focus sui dati e sulla logica applicativa};
				
				% Icone utenti
				\draw[fill=blue!40] (1,6.7) circle (0.15cm);
				\draw[fill=blue!40] (1,6.4) -- (0.8,6) -- (1.2,6) -- cycle;
				
				\draw[fill=blue!40] (2.75,6.7) circle (0.15cm);
				\draw[fill=blue!40] (2.75,6.4) -- (2.55,6) -- (2.95,6) -- cycle;
				
				\draw[fill=blue!40] (4.5,6.7) circle (0.15cm);
				\draw[fill=blue!40] (4.5,6.4) -- (4.3,6) -- (4.7,6) -- cycle;
				
				% Frecce bidirezionali
				\draw[<->, ultra thick, green!60!black] (2.75,6.3) -- (2.75,5.8);
				
				% LIVELLO DBMS (centrale e più importante)
				\draw[fill=green!30, rounded corners, drop shadow, line width=1.5pt] (-0.3,3.8) rectangle (5.8,5.6);
				\draw (2.75,5.3) node[font=\large\bfseries] {DBMS};
				\draw (2.75,4.9) node[font=\bfseries] {(DataBase Management System)};
				
				% Funzioni del DBMS
				\draw[fill=green!50, rounded corners] (0,4.2) rectangle (2.3,4.7);
				\draw (1.15,4.45) node[font=\tiny] {Gestione query};
				
				\draw[fill=green!50, rounded corners] (2.5,4.2) rectangle (5.5,4.7);
				\draw (4,4.45) node[font=\tiny] {Controllo accessi e sicurezza};
				
				\draw[fill=green!50, rounded corners] (0,3.9) rectangle (2.3,4.1);
				\draw (1.15,4) node[font=\tiny] {Gestione transazioni};
				
				\draw[fill=green!50, rounded corners] (2.5,3.9) rectangle (5.5,4.1);
				\draw (4,4) node[font=\tiny] {Ottimizzazione};
				
				% Frecce bidirezionali
				\draw[<->, ultra thick, orange!70!black] (2.75,3.6) -- (2.75,3.1);
				
				% LIVELLO FISICO/HARDWARE
				\draw[fill=gray!30, rounded corners, drop shadow] (0,0.5) rectangle (5.5,2.9);
				\draw (2.75,2.6) node[font=\small\bfseries] {LIVELLO FISICO};
				\draw (2.75,2.2) node[font=\tiny, align=center] {Hardware, file system, memoria};
				
				% Componenti hardware
				\draw[fill=gray!50, rounded corners] (0.3,1.5) rectangle (1.8,2);
				\draw (1.05,1.75) node[font=\tiny] {Hard Disk};
				
				\draw[fill=gray!50, rounded corners] (2,1.5) rectangle (3.5,2);
				\draw (2.75,1.75) node[font=\tiny] {SSD};
				
				\draw[fill=gray!50, rounded corners] (3.7,1.5) rectangle (5.2,2);
				\draw (4.45,1.75) node[font=\tiny] {RAM};
				
				\draw[fill=gray!50, rounded corners] (0.3,0.7) rectangle (2.6,1.3);
				\draw (1.45,1) node[font=\tiny] {File System};
				
				\draw[fill=gray!50, rounded corners] (2.9,0.7) rectangle (5.2,1.3);
				\draw (4.05,1) node[font=\tiny] {Gestione I/O};
				
				% Etichette laterali
				\draw[fill=yellow!20, rounded corners] (6,6.8) rectangle (7.8,7.5);
				\draw (6.9,7.15) node[font=\tiny, align=center] {Cosa\\conosce\\l'utente};
				
				\draw[fill=red!20, rounded corners] (6,1.5) rectangle (7.8,2.2);
				\draw (6.9,1.85) node[font=\tiny, align=center] {Cosa\\NON deve\\conoscere};
				
				% Barriera di astrazione
				\draw[dashed, thick, red] (5.9,3.7) -- (7.9,3.7);
				\draw (6.9,3.4) node[font=\tiny\bfseries, red, align=center] {Barriera di\\astrazione};
				
			\end{tikzpicture}
		\end{column}
	\end{columns}
\end{frame}


\begin{frame}{DBMS}
	\begin{figure}
		\centering
		\includegraphics[width=0.7\linewidth]{basi_di_dati}
		\caption[DBMS]{DBMS}
		\label{fig:dbms}
	\end{figure}
	
\end{frame}


\begin{frame}{I DBMS}
In questo modo l'utente del database può concentrare la sua attenzione sul:
\begin{itemize}
\item progetto degli archivi
\item sulla gestione e sul ritrovamento delle informazioni
\end{itemize}

senza preoccuparsi del modo con il quale avviene l'organizzazione fisica dei dati sulle memorie di massa, compito che rimane a carico del software di gestione della base di dati.
\end{frame}

\begin{frame}{I DBMS}
Questo crea una distinzione tra:
\begin{itemize}
\item \textbf{utenti finali} che utilizzano le informazioni contenute nel database
\item \textbf{amministratori del database} che si occupano della progettazione e della manutenzione degli archivi
\end{itemize}

Questa distinzione corrisponde alla differenza tra:
\begin{itemize}
\item \textbf{struttura concettuale} → modo attraverso il quale l'utente pensa all'organizzazione e al ritrovamento dei dati
\item \textbf{struttura fisica dei dati} → tecniche utilizzate dal sistema operativo per registrare e leggere negli archivi
\end{itemize}
\end{frame}

\begin{frame}{Database vs DBMS}
A questo proposito si tenga ben presente anche la differenza tra:
\begin{itemize}
\item \textbf{Database} come insieme di dati
\item \textbf{DBMS} come sistema per la gestione del database
\end{itemize}

così come nell'uso degli archivi tradizionali c'è una distinzione tra archivi di dati e file system.
\end{frame}

\begin{frame}{I DBMS - database distribuiti}
	\begin{columns}[T]
		\begin{column}{0.48\textwidth}
			\begin{itemize}
				\item Gli utenti della base di dati elaborano in modo locale gli archivi che hanno a disposizione nel proprio sistema e nello stesso tempo accedono in modo remoto a sistemi centrali attraverso le linee di comunicazione.
				\item Gli archivi integrati che costituiscono la base di dati aziendale possono risiedere su un unico computer oppure possono essere distribuiti sulle memorie di massa di computer diversi, facenti parte di una rete aziendale, i cui nodi possono essere anche fisicamente lontani: in questo caso si parla di \textbf{database distribuiti}.
			\end{itemize}
		\end{column}
		
		\begin{column}{0.48\textwidth}
			\begin{tikzpicture}[scale=0.75, every node/.style={font=\scriptsize}]
				
				% RETE DI COMUNICAZIONE (al centro)
				\draw[dashed, thick, blue!50] (3,3.5) circle (2.5cm);
				\draw (3,3.5) node[font=\small\bfseries, blue] {RETE AZIENDALE};
				
				% SERVER CENTRALE (in alto)
				\draw[fill=red!30, rounded corners, drop shadow] (2.2,6.5) rectangle (3.8,7.5);
				\draw (3,7.2) node[font=\tiny\bfseries] {Server Centrale};
				\draw (3,6.8) node[font=\tiny] {Roma};
				
				% Database centrale
				\draw[fill=yellow!40, rounded corners] (2.4,6) rectangle (3.6,6.4);
				\draw (3,6.2) node[font=\tiny] {DB};
				
				% Linea verso la rete
				\draw[->, thick, blue] (3,6) -- (3,5.5);
				
				% NODO LOCALE 1 (sinistra)
				\draw[fill=green!30, rounded corners, drop shadow] (0,3) rectangle (1.5,4);
				\draw (0.75,3.7) node[font=\tiny\bfseries] {Nodo Locale};
				\draw (0.75,3.4) node[font=\tiny] {Milano};
				
				% Database locale 1
				\draw[fill=cyan!40, rounded corners] (0.2,2.5) rectangle (1.3,2.9);
				\draw (0.75,2.7) node[font=\tiny] {DB};
				
				% Utente 1
				\draw[fill=blue!40] (0.75,3.2) circle (0.1cm);
				\draw (0.75,2.3) node[font=\tiny] {Utente};
				
				% Linea verso la rete
				\draw[->, thick, blue] (1.5,3.5) -- (2,3.5);
				
				% NODO LOCALE 2 (destra)
				\draw[fill=green!30, rounded corners, drop shadow] (4.5,3) rectangle (6,4);
				\draw (5.25,3.7) node[font=\tiny\bfseries] {Nodo Locale};
				\draw (5.25,3.4) node[font=\tiny] {Napoli};
				
				% Database locale 2
				\draw[fill=cyan!40, rounded corners] (4.7,2.5) rectangle (5.8,2.9);
				\draw (5.25,2.7) node[font=\tiny] {DB};
				
				% Utente 2
				\draw[fill=blue!40] (5.25,3.2) circle (0.1cm);
				\draw (5.25,2.3) node[font=\tiny] {Utente};
				
				% Linea verso la rete
				\draw[->, thick, blue] (4,3.5) -- (4.5,3.5);
				
				% NODO LOCALE 3 (in basso a sinistra)
				\draw[fill=green!30, rounded corners, drop shadow] (0.5,0.3) rectangle (2,1.3);
				\draw (1.25,1) node[font=\tiny\bfseries] {Nodo Locale};
				\draw (1.25,0.7) node[font=\tiny] {Torino};
				
				% Database locale 3
				\draw[fill=cyan!40, rounded corners] (0.7,0) rectangle (1.8,0.2);
				\draw (1.25,0.1) node[font=\tiny] {DB};
				
				% Linea verso la rete
				\draw[->, thick, blue] (1.8,1) -- (2.3,2.5);
				
				% NODO LOCALE 4 (in basso a destra)
				\draw[fill=green!30, rounded corners, drop shadow] (4,0.3) rectangle (5.5,1.3);
				\draw (4.75,1) node[font=\tiny\bfseries] {Nodo Locale};
				\draw (4.75,0.7) node[font=\tiny] {Bologna};
				
				% Database locale 4
				\draw[fill=cyan!40, rounded corners] (4.2,0) rectangle (5.3,0.2);
				\draw (4.75,0.1) node[font=\tiny] {DB};
				
				% Linea verso la rete
				\draw[->, thick, blue] (4.2,1) -- (3.7,2.5);
				
				% Frecce di comunicazione tra nodi
				\draw[<->, thick, orange, dashed] (1.5,3.5) -- (4.5,3.5);
				\draw (3,3.8) node[font=\tiny, orange] {comunicazione};
				
				% Legende
				\draw[fill=yellow!20, rounded corners] (6.3,6.5) rectangle (8,7.5);
				\draw (7.15,7.2) node[font=\tiny\bfseries] {Accesso Remoto};
				\draw (7.15,6.8) node[font=\tiny, align=center] {Dati\\centralizzati};
				
				\draw[fill=cyan!20, rounded corners] (6.3,5.3) rectangle (8,6.3);
				\draw (7.15,6) node[font=\tiny\bfseries] {Accesso Locale};
				\draw (7.15,5.6) node[font=\tiny, align=center] {Elaborazione\\dati locali};
				
				\draw[fill=orange!20, rounded corners] (6.3,4.1) rectangle (8,5.1);
				\draw (7.15,4.8) node[font=\tiny\bfseries] {Distribuzione};
				\draw (7.15,4.4) node[font=\tiny, align=center] {Database\\distribuito\\su più nodi};
				
			\end{tikzpicture}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{I DBMS}
\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{database_distribuiti}
	\caption[Database distribuiti]{}
	\label{fig:databasedistribuiti}
\end{figure}

\end{frame}

\begin{frame}{Limiti dell'organizzazione tradizionale degli archivi}
\textbf{Ridondanza e inconsistenza dei dati.}
\begin{itemize}
\item La \textbf{ridondanza} nei dati è frequente nell'approccio basato su file indipendenti.
\item La \textbf{duplicazione} dei dati richiede di inserirli più volte, con l'aumento dello spazio occupato dai dati, ma, soprattutto, la ridondanza può portare all'\textbf{incongruenza} nel caso in cui un dato sia aggiornato in un archivio e non in un altro, oppure siano presenti valori diversi per lo stesso dato.

\end{itemize}


\end{frame}

\begin{frame}{Limiti dell'organizzazione tradizionale degli archivi}
\begin{itemize}
\item L'incongruenza porta a sua volta all'\textbf{inconsistenza} dei dati, cioè i dati a disposizione non sono più affidabili, perché non si sa quale sia quello corretto.
\end{itemize}

\textbf{Difficoltà nell'accesso ai dati}

L'accesso ai dati dipende dall'organizzazione scelta per gli archivi. Di conseguenza il programmatore deve accedere agli archivi con le modalità previste per l'organizzazione scelta e deve limitare le operazioni ammissibili sugli stessi.
\end{frame}

\begin{frame}{Limiti dell'organizzazione tradizionale degli archivi}
\textbf{Isolamento dei dati, dati di differente formato.}

I dati sono dispersi tra diversi file e sono rappresentati con differenti formati a causa, per esempio, dell'uso di differenti linguaggi nello sviluppo di diverse parti di un'applicazione: di conseguenza diventa difficile collegare i dati tra di loro e integrarli.

\textbf{Dipendenza dai dati.}

I programmi sono dipendenti dagli archivi che gestiscono, perché i linguaggi di programmazione richiedono di specificare, all'interno di ogni programma, quali sono gli archivi utilizzati e la struttura dei loro record.
\end{frame}

\begin{frame}{Limiti dell'organizzazione tradizionale degli archivi}
\textbf{Difficoltà nel gestire l'integrità dei dati.}

I vincoli di integrità si possono rappresentare solo scrivendo un apposito codice nei programmi che manipolano i dati.

Di conseguenza i vincoli di integrità non sono dichiarati esplicitamente ma sono impliciti, distribuiti e nascosti nel software e di difficile documentazione.

\textbf{Interrogazioni predefinite.}

È possibile accedere ai dati solo tramite un numero limitato di applicazioni sviluppate ad hoc. Per ogni altra esigenza informativa bisogna sviluppare nuove applicazioni.
\end{frame}

\begin{frame}{Limiti dell'organizzazione tradizionale degli archivi}
\textbf{Complessità nell'aggiornamento del software e delle strutture dati}

Ogni aggiornamento del software e ogni nuova applicazione deve tenere conto dei vincoli d'integrità inserendoli nei programmi mediante specifiche istruzioni.

Qualsiasi modifica alla struttura del record richiede la modifica di tutti i programmi che utilizzano quel record.
\end{frame}

% ========== I MODELLI PER IL DATABASE ==========
\subsection{Modelli per i database}
\begin{frame}
	\begin{center}
		{\LARGE \textbf{Modelli per i database}}
	\end{center}
\end{frame}

\begin{frame}{I modelli per il database}
	\begin{itemize}
		\item Il database è un modello della realtà considerata: i contenuti della base di dati rappresentano gli stati in cui si trova la realtà da modellare.
		\item I cambiamenti che vengono apportati alla base di dati rappresentano gli eventi che avvengono nell'ambiente in cui opera l'azienda.
		Per descrivere i dati, il loro significato, come sono correlati e i vincoli definiti su di essi si fa uso di \textbf{modelli dei dati}.
		\end{itemize}

\end{frame}

\begin{frame}{I modelli per il database}
Essi sono classificabili secondo diversi livelli di generalità:

\begin{itemize}
\item \textbf{modello concettuale} (o modello a livello di oggetti)
\item \textbf{modello logico dei dati} (o modello a livello di record)
\item \textbf{modello fisico dei dati}, che si occupa delle modalità e delle tecniche usate nella registrazione sulle memorie di massa
\end{itemize}

L'uso efficace dei dati organizzati in un database presuppone un attento lavoro di progettazione iniziale, che viene fatto con riferimento ai dati che si vogliono memorizzare e successivamente elaborare.
\end{frame}

% ========== IL MODELLO CONCETTUALE ==========
\begin{frame}{Il modello concettuale}
Tra i numerosi modelli proposti per la progettazione concettuale, il più noto è il \textbf{modello Entità/Associazioni}, indicato come \textbf{modello E/R} dal termine inglese Entity/Relationship.

Nella costruzione del modello E/R di una realtà si individuano:
\begin{itemize}
\item gli oggetti che la compongono, detti \textbf{entità}
\item poi gli \textbf{attributi}, che rappresentano le caratteristiche delle entità individuate
\item e infine le \textbf{associazioni}, che descrivono le correlazioni logiche tra entità
\end{itemize}

Entità, attributi, associazioni sono rappresentati graficamente in un \textbf{diagramma E/R}.
\end{frame}

\begin{frame}{Il modello concettuale}
\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{diagramma_er}
	\caption[Diagramma E-R]{Modello concettuale}
	\label{fig:diagrammaer}
\end{figure}

\begin{itemize}
\item ogni cliente deve possedere uno e un solo conto;
\item ogni conto deve essere posseduto da uno o più clienti;
\item ogni conto può essere variato da uno o più movimenti e ci possono essere conti non movimentati;
\item ogni movimento deve variare uno e un solo conto.
\end{itemize}
\end{frame}

% ========== IL MODELLO LOGICO ==========
\begin{frame}{Il modello logico}
A partire dallo schema concettuale Entità/Associazioni, un database può essere progettato e realizzato passando al \textbf{modello logico}, cioè alle strutture che organizzano i dati, in modo da consentire le operazioni di manipolazione e di interrogazione.

Nello sviluppo della teoria dei database, a partire dagli anni Sessanta, sono emersi tre diversi tipi di modelli a livello di record per le basi di dati:
\begin{itemize}
\item il modello gerarchico
\item il modello reticolare
\item il modello relazionale
\end{itemize}
\end{frame}


\begin{frame}{Il modello logico}
	\begin{itemize}
	\item I modelli gerarchico e reticolare sono stati definiti attraverso un processo di astrazione da sistemi già implementati, mentre il modello relazionale è stato definito a livello teorico prima di qualsiasi implementazione sul computer.
\item Il modello relazionale nasce nel 1970, proposto da \textbf{Edgar F. Codd}, ricercatore IBM, come idea di un modello logico molto semplice e nello stesso tempo in grado di superare i limiti degli altri modelli utilizzati.
	
	\end{itemize}

\end{frame}

% ========== IL MODELLO RELAZIONALE ==========
\subsection{Modello relazionale}
\begin{frame}
\begin{center}
{\LARGE \textbf{Modello relazionale}}
\end{center}
\end{frame}

\begin{frame}
\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{modello_relazionale}
	\caption[Modello relazionale]{}
	\label{fig:modellorelazionale}
\end{figure}

\end{frame}

\begin{frame}{Il modello relazionale}
Il modello relazionale si basa su alcuni concetti fondamentali tipicamente matematici e assegna grande importanza all'uso rigoroso del linguaggio matematico, con due obiettivi importanti:

\begin{itemize}
\item utilizzare un linguaggio conosciuto a livello universale, quale è il linguaggio matematico;
\item eliminare i problemi di ambiguità nella terminologia e nella simbologia
\end{itemize}

Il modello relazionale è un \textbf{modello basato sui valori}. Le associazioni tra entità sono descritte solamente tramite i valori assunti da campi, nelle righe delle tabelle che modellano le entità stesse, senza fare uso di puntatori.
\end{frame}


\begin{frame}{Altri modelli}
	\begin{itemize}
\item La diffusione del \textbf{modello relazionale} è cresciuta nel tempo in coincidenza con la crescita della capacità delle memorie centrali e della potenza di calcolo dei processori, che hanno permesso di manipolare le tabelle con sempre maggior rapidità.
\item Invece i database costruiti sul \textbf{modello gerarchico e reticolare}, meno esigenti in termini di prestazioni dell'hardware, erano più adeguati alle limitate prestazioni delle macchine degli anni Settanta.
	\end{itemize}

\end{frame}

\begin{frame}
\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{modello_gerarchico}
	\caption[Modello gerarchico]{Modello gerarchico}
	\label{fig:modellogerarchico}
\end{figure}

\end{frame}


\begin{frame}{Modello gerarchico e reticolare}
	\begin{columns}
		\column{0.55\textwidth}
		\begin{itemize}
			\item Le operazioni sui database gerarchici e reticolari sono complesse, poiché agiscono su singoli record che vengono identificati specificando i percorsi per ritrovarli.
			\item Si dice in tale caso che l'approccio adottato nell'elaborazione dei dati è di tipo \textbf{procedurale}, ovvero bisogna indicare al computer come deve fare per trovare i dati.
			\item I sistemi relazionali adottano invece un approccio di tipo \textbf{dichiarativo} nell'elaborazione delle informazioni, in quanto viene specificato cosa si vuole trovare, mentre i percorsi per trovare i dati sono a carico del sistema.
		\end{itemize}
		
		\column{0.45\textwidth}
		\begin{center}
			\begin{tikzpicture}[scale=0.8]
				% Approccio procedurale
				\node[font=\small\bfseries] at (0,3.5) {Procedurale};
				\node[draw, rectangle, fill=red!20, minimum width=2cm, minimum height=0.6cm] (user1) at (0,2.8) {Utente};
				\node[draw, rectangle, fill=blue!20, minimum width=2cm, minimum height=0.6cm] (db1) at (0,1.2) {Database};
				\draw[->, thick, red] (user1) -- node[right, font=\scriptsize] {COME} (db1);
				
				% Spazio
				\draw[dashed, gray] (-1.5,0.5) -- (1.5,0.5);
				
				% Approccio dichiarativo
				\node[font=\small\bfseries] at (0,-0.2) {Dichiarativo};
				\node[draw, rectangle, fill=green!20, minimum width=2cm, minimum height=0.6cm] (user2) at (0,-0.9) {Utente};
				\node[draw, rectangle, fill=blue!20, minimum width=2cm, minimum height=0.6cm] (db2) at (0,-2.5) {Database};
				\draw[->, thick, green!60!black] (user2) -- node[right, font=\scriptsize] {COSA} (db2);
			\end{tikzpicture}
		\end{center}
	\end{columns}
\end{frame}



\begin{frame}{Il modello relazionale}
	\begin{columns}
		\column{0.6\textwidth}
		\begin{itemize}
			\item Tra i modelli di database illustrati, il modello relazionale è il più diffuso nella quasi totalità dei prodotti commerciali DBMS, nei sistemi di elaborazione grandi, medi e piccoli.
			\item Proprio questo modello ha determinato un'ampia diffusione dei programmi per la gestione di database anche per i personal computer.
		\end{itemize}
		
		\column{0.4\textwidth}
		\begin{center}
			\begin{tikzpicture}[scale=0.7]
				% Tabella esempio
				\node[font=\small\bfseries] at (0,3.2) {Tabella Relazionale};
				
				% Header
				\draw[fill=blue!30, thick] (-2,2.5) rectangle (-0.5,2);
				\draw[fill=blue!30, thick] (-0.5,2.5) rectangle (1,2);
				\draw[fill=blue!30, thick] (1,2.5) rectangle (2.5,2);
				
				\node[font=\scriptsize] at (-1.25,2.25) {\textbf{ID}};
				\node[font=\scriptsize] at (0.25,2.25) {\textbf{Nome}};
				\node[font=\scriptsize] at (1.75,2.25) {\textbf{Città}};
				
				% Righe
				\draw (-2,2) rectangle (-0.5,1.5);
				\draw (-0.5,2) rectangle (1,1.5);
				\draw (1,2) rectangle (2.5,1.5);
				\node[font=\tiny] at (-1.25,1.75) {1};
				\node[font=\tiny] at (0.25,1.75) {Mario};
				\node[font=\tiny] at (1.75,1.75) {Roma};
				
				\draw (-2,1.5) rectangle (-0.5,1);
				\draw (-0.5,1.5) rectangle (1,1);
				\draw (1,1.5) rectangle (2.5,1);
				\node[font=\tiny] at (-1.25,1.25) {2};
				\node[font=\tiny] at (0.25,1.25) {Luca};
				\node[font=\tiny] at (1.75,1.25) {Milano};
				
				\draw (-2,1) rectangle (-0.5,0.5);
				\draw (-0.5,1) rectangle (1,0.5);
				\draw (1,1) rectangle (2.5,0.5);
				\node[font=\tiny] at (-1.25,0.75) {3};
				\node[font=\tiny] at (0.25,0.75) {Anna};
				\node[font=\tiny] at (1.75,0.75) {Napoli};
				
				% Icone sistemi
				\node[font=\scriptsize] at (-1.5,-0.3) {Server};
				\node[font=\scriptsize] at (0.2,-0.3) {Desktop};
				\node[font=\scriptsize] at (1.8,-0.3) {Mobile};
				
				% Simboli
				\draw[fill=gray!40] (-1.7,-1) rectangle (-1.3,-1.4);
				\draw[fill=gray!60] (-1.7,-1.4) rectangle (-1.3,-1.5);
				
				\draw[fill=gray!40] (0,-1.2) rectangle (0.4,-0.8);
				\draw[fill=gray!60] (0,-0.8) rectangle (0.4,-0.7);
				
				\draw[fill=gray!40] (1.6,-1.3) -- (2,-1.3) -- (2,-0.9) -- (1.6,-0.9) -- cycle;
				\draw (1.75,-1.1) circle (0.08);
				
			\end{tikzpicture}
		\end{center}
	\end{columns}
\end{frame}

% ========== IL MODELLO FISICO ==========
\begin{frame}{Il modello fisico}
	\begin{columns}
		\column{0.58\textwidth}
		\begin{itemize}
\item 		Il \textbf{modello fisico} dei dati ha la funzione di descrivere il modo con il quale un dato modello logico è realizzato concretamente sulle memorie di massa del computer.

\item 		Nel caso del modello relazionale, il modello fisico precisa come sono realizzate le tabelle, il modo per implementare i vincoli sui dati che le compongono, come rappresentare le associazioni tra tabelle, come costruire gli indici sui campi di una tabella e così via.

\item 
		Il modello fisico si occupa di problemi trattati dai progettisti di uno specifico DBMS. Esempi di prodotti DBMS che gestiscono i modelli fisici dei dati sono Oracle, DB2, MySQL, SQL Server, Access.

		\end{itemize}
		
		
		
		\column{0.42\textwidth}
		\begin{center}
			\begin{tikzpicture}[scale=0.75]
				% Livello Logico
				\node[font=\small\bfseries, blue] at (0,4) {Modello Logico};
				\draw[fill=blue!20, rounded corners] (-1.8,3.5) rectangle (1.8,2.8);
				\node[font=\tiny, align=center] at (0,3.15) {Tabella STUDENTI\\ID, Nome, Cognome};
				
				% Freccia
				\draw[->, very thick, blue!60] (0,2.8) -- (0,2.3);
				
				% Livello Fisico
				\node[font=\small\bfseries, orange!80!black] at (0,2) {Modello Fisico};
				
				% Disco
				\draw[fill=gray!30] (0,0.5) ellipse (1.5 and 0.3);
				\draw[fill=gray!40] (-1.5,0.5) -- (-1.5,-0.8) arc (180:360:1.5 and 0.3) -- (1.5,0.5);
				\draw[fill=gray!30] (0,-0.8) ellipse (1.5 and 0.3);
				
				% Dettagli su disco
				\node[font=\tiny, align=left] at (0,0.3) {File dati};
				\node[font=\tiny, align=left] at (0,-0.1) {Indici};
				\node[font=\tiny, align=left] at (0,-0.5) {Vincoli};
				
				% DBMS
				\node[font=\scriptsize, align=center, fill=green!20, rounded corners, draw] at (0,-1.7) {DBMS\\Oracle, MySQL\\SQL Server...};
				
			\end{tikzpicture}
		\end{center}
	\end{columns}
\end{frame}

% ========== ARCHITETTURA A TRE LIVELLI ==========
\begin{frame}{Architettura a tre livelli e indipendenza dei dati}
I software DBMS seguono, di fatto, l'impostazione concettuale dell'\textbf{architettura a tre livelli ANSI-SPARC}, proposta nel 1975 da un comitato (Standard Planning And Requirements Committee) dell'ANSI (American National Standards Institute).

Secondo questa impostazione i dati sono descritti secondo tre differenti livelli di astrazione, mediante opportuni schemi. I tre livelli sono indicati come:
\begin{itemize}
\item il livello esterno
\item il livello logico
\item il livello interno
\end{itemize}

Il \textbf{livello esterno (viste)} rappresenta la visione del database da parte dell'utente. Descrive la parte del database che è importante per il singolo utente o per un gruppo di utenti.
\end{frame}

\begin{frame}{Architettura a tre livelli e indipendenza dei dati}
	\begin{columns}
		\column{0.55\textwidth}
		\begin{itemize}
			\item In generale in un database ci sono tanti \textbf{schemi esterni} quante sono le classi di utente con differenti esigenze e visione dei dati.
			\item Il \textbf{livello logico} rappresenta la visione complessiva del database dal punto di vista logico, indipendentemente dalle modalità e dalle tecniche di memorizzazione dei dati.
			\item Il livello logico descrive, con le convenzioni del modello di database scelto, entità, attributi, associazioni e vincoli.
			\item Il livello logico è la cerniera tra ciò che vedono gli utenti e quello che viene effettivamente memorizzato nel computer.
		\end{itemize}
		
		\column{0.45\textwidth}
		\begin{center}
			\begin{tikzpicture}[scale=0.8]
				% Livello Esterno
				\node[font=\small\bfseries] at (0,4.2) {Livello Esterno};
				\draw[fill=green!20, rounded corners] (-1.5,3.8) rectangle (-0.3,3.3);
				\node[font=\tiny] at (-0.9,3.55) {Vista 1};
				\draw[fill=green!20, rounded corners] (0.3,3.8) rectangle (1.5,3.3);
				\node[font=\tiny] at (0.9,3.55) {Vista 2};
				\draw[fill=green!20, rounded corners] (-0.6,3.2) rectangle (0.6,2.7);
				\node[font=\tiny] at (0,2.95) {Vista N};
				
				% Frecce verso livello logico
				\draw[->, thick] (-0.9,3.3) -- (-0.5,2.5);
				\draw[->, thick] (0.9,3.3) -- (0.5,2.5);
				\draw[->, thick] (0,2.7) -- (0,2.5);
				
				% Livello Logico (cerniera)
				\node[font=\small\bfseries] at (0,2.2) {Livello Logico};
				\draw[fill=blue!30, rounded corners] (-1.8,1.8) rectangle (1.8,0.8);
				\node[font=\tiny, align=center] at (0,1.5) {Schema logico};
				\node[font=\tiny, align=center] at (0,1.1) {Entità, Attributi\\Associazioni, Vincoli};
				
				% Freccia verso livello fisico
				\draw[->, thick] (0,0.8) -- (0,0.4);
				
				% Livello Fisico
				\node[font=\small\bfseries] at (0,0.1) {Livello Fisico};
				\draw[fill=orange!20, rounded corners] (-1.5,-0.3) rectangle (1.5,-1.3);
				\node[font=\tiny, align=center] at (0,-0.6) {Memorizzazione};
				\node[font=\tiny, align=center] at (0,-1) {File, Indici, Strutture};
				
			\end{tikzpicture}
		\end{center}
	\end{columns}
\end{frame}

\begin{frame}{Architettura a tre livelli e indipendenza dei dati}
	\begin{columns}
		\column{0.55\textwidth}
		\begin{itemize}
			\item Naturalmente c'è un solo \textbf{schema logico} di database.
			\item Il \textbf{livello interno (fisico)} riguarda la rappresentazione fisica del database nel computer e fornisce informazioni in merito alla realizzazione concreta del livello logico.
			\item Il livello interno entra nel merito dei dettagli implementativi delle forme di memorizzazione.
			\item \textbf{Esempio:} Una tabella di un database relazionale può essere rappresentata con un file ad accesso diretto e con una struttura a indice sequenziale per la chiave primaria.
			\item Nel caso di database gerarchico o reticolare, il livello interno realizza mediante puntatori gli archi che collegano i nodi.
		\end{itemize}
		
		\column{0.45\textwidth}
		\begin{center}
			\begin{tikzpicture}[scale=0.75]
				% Schema Logico
				\node[font=\small\bfseries, blue] at (0,3.8) {Schema Logico};
				\draw[fill=blue!20, rounded corners] (-1.6,3.4) rectangle (1.6,2.6);
				\node[font=\tiny, align=center] at (0,3) {Tabella CLIENTI\\ID (PK), Nome, Email};
				
				% Freccia
				\draw[->, very thick, orange!70] (0,2.6) -- (0,2.1);
				\node[font=\tiny, right] at (0.1,2.35) {mappatura};
				
				% Livello Fisico
				\node[font=\small\bfseries, orange!80!black] at (0,1.8) {Livello Fisico};
				
				% File dati
				\draw[fill=gray!20, rounded corners] (-1.8,1.4) rectangle (1.8,0.6);
				\node[font=\tiny, align=left] at (-1.5,1.2) {\textbf{File dati:}};
				\node[font=\tiny, align=left] at (-1.5,0.95) {record 1: |1|Mario|...};
				\node[font=\tiny, align=left] at (-1.5,0.75) {record 2: |2|Luca|...};
				
				% Indice
				\draw[fill=yellow!20, rounded corners] (-1.8,0.3) rectangle (1.8,-0.4);
				\node[font=\tiny, align=left] at (-1.5,0.1) {\textbf{Indice su ID:}};
				\node[font=\tiny, align=left] at (-1.5,-0.15) {1 → ptr\_rec1};
				\node[font=\tiny, align=left] at (-1.5,-0.35) {2 → ptr\_rec2};
				
				% Disco
				\draw[fill=gray!40] (-0.6,-1.2) rectangle (0.6,-0.8);
				\draw[fill=gray!50] (-0.6,-0.8) rectangle (0.6,-0.7);
				\node[font=\tiny] at (0,-1) {HDD/SSD};
				
			\end{tikzpicture}
		\end{center}
	\end{columns}
\end{frame}

\begin{frame}{Architettura a tre livelli e indipendenza dei dati}
In un semplice database:
\begin{itemize}
\item il livello esterno è composto dalle cinque differenti visioni dei dati che hanno gli impiegati dei cinque dipartimenti;
\item il livello logico è costituito dalla coppia di tabelle Dipartimenti e Studenti;
\item il livello interno descrive come sono memorizzate le tabelle Studenti e Dipartimenti e dipende dal DBMS scelto;
\item al di sotto del livello interno ci sono i bit, o meglio i blocchi di byte, su disco che sono di competenza del sistema operativo.
\end{itemize}
\end{frame}

\begin{frame}{Architettura a tre livelli e indipendenza dei dati}
	\begin{columns}
		\column{0.52\textwidth}
		\begin{itemize}
			\item Il DBMS mantiene al proprio interno la descrizione delle viste logiche (schemi esterni), dello schema logico e dello schema interno del database.
			\item In base a queste informazioni, il DBMS è in grado di attuare la corrispondenza (\textit{mapping}) tra:
			\begin{itemize}
				\item[\tiny$\blacksquare$] viste logiche e schema logico
				\item[\tiny$\blacksquare$] schema logico e livello interno
			\end{itemize}
			\item \textbf{Esempio:} Un impiegato di Ingegneria desidera accedere alle informazioni anagrafiche dello studente Nino Verdi.
			\item Il DBMS traduce la richiesta nella ricerca dei record di Studenti con quel nome e cognome, ma con campo CodDip = 'Ing', identificando il record con Matricola = 2340.
		\end{itemize}
		
		\column{0.48\textwidth}
		\begin{center}
			\begin{tikzpicture}[scale=0.7]
				% Vista Utente
				\node[font=\scriptsize\bfseries, green!60!black] at (0,4.3) {Vista Ingegneria};
				\draw[fill=green!15, rounded corners] (-1.8,4) rectangle (1.8,3.4);
				\node[font=\tiny, align=center] at (0,3.7) {Richiesta: "Nino Verdi"};
				
				% Mapping 1
				\draw[->, thick, blue] (0,3.4) -- (0,3);
				\node[font=\tiny, right, blue] at (0.1,3.2) {mapping};
				
				% Schema Logico
				\node[font=\scriptsize\bfseries, blue] at (0,2.7) {Schema Logico};
				\draw[fill=blue!15, rounded corners] (-1.8,2.4) rectangle (1.8,1.5);
				\node[font=\tiny, align=left] at (-1.6,2.15) {SELECT * FROM Studenti};
				\node[font=\tiny, align=left] at (-1.6,1.9) {WHERE Nome='Nino'};
				\node[font=\tiny, align=left] at (-1.6,1.65) {AND Cognome='Verdi'};
				\node[font=\tiny, align=left] at (-1.6,1.4) {AND CodDip='Ing'};
				
				% Mapping 2
				\draw[->, thick, orange!70] (0,1.5) -- (0,1.1);
				\node[font=\tiny, right, orange!70] at (0.1,1.3) {mapping};
				
				% Livello Fisico
				\node[font=\scriptsize\bfseries, orange!80!black] at (0,0.8) {Livello Fisico};
				\draw[fill=orange!15, rounded corners] (-1.8,0.5) rectangle (1.8,-0.5);
				\node[font=\tiny, align=left] at (-1.6,0.3) {Record trovato:};
				\node[font=\tiny, align=left] at (-1.6,0) {Mat: 2340 | Nino | Verdi};
				\node[font=\tiny, align=left] at (-1.6,-0.25) {CodDip: Ing | ...};
				
				% DBMS
				\draw[fill=gray!20, rounded corners] (-1.5,-1) rectangle (1.5,-1.5);
				\node[font=\tiny\bfseries] at (0,-1.25) {DBMS (gestore mapping)};
				
			\end{tikzpicture}
		\end{center}
	\end{columns}
\end{frame}


\begin{frame}{Architettura a tre livelli e indipendenza dei dati}
L'architettura a tre livelli dei database realizza meccanismi di astrazione dei dati e assicura la cosiddetta \textbf{indipendenza dei dati}.

Con questo termine si vuole indicare il fatto che i livelli superiori non sono influenzati, entro certi limiti, dai cambiamenti che avvengono nei livelli inferiori dell'architettura.

Si identificano due livelli di indipendenza dei dati:
\begin{itemize}
\item l'indipendenza logica
\item l'indipendenza fisica
\end{itemize}
\end{frame}

% ========== LA GESTIONE DEL DATABASE ==========
\begin{frame}{La gestione del database}
Il DBMS è il software che consente di costruire e gestire una base di dati, realizzandola nella pratica su memoria di massa, a partire da un progetto e da uno schema dei dati definiti a livello concettuale e tradotti poi in un modello logico dei dati.
\end{frame}

\begin{frame}{La gestione del database}
Le funzioni che il DBMS, attraverso i suoi moduli software, è in grado di offrire agli utenti del database si possono raggruppare in sei categorie.

\textbf{1. L'implementazione del modello logico sul sistema di elaborazione.}

\begin{itemize}
\item Definizione dei dati e delle strutture dati derivate dallo schema logico (tipicamente le tabelle del modello relazionale), con produzione della documentazione sul modello.
\end{itemize}
\end{frame}

\begin{frame}{La gestione del database}
	\begin{columns}
		\column{0.55\textwidth}
		\begin{itemize}
			\item Definizione dei \textbf{sottoschemi (viste logiche)} che consentono agli utenti di accedere ai soli dati ai quali sono interessati in base alle proprie esigenze applicative.
			\item Una \textbf{vista logica} è una tabella virtuale, mentre le tabelle del database sono indicate come \textbf{tabelle primarie}.
			\item Le viste logiche sono \textbf{finestre dinamiche} sulle tabelle del database.
			\item Ogni modifica ai dati delle tabelle primarie si riflette sulle viste corrispondenti e viceversa.
		\end{itemize}
		
		\column{0.45\textwidth}
		\begin{center}
			\begin{tikzpicture}[scale=0.7]
				% Tabella Primaria
				\node[font=\small\bfseries, blue] at (0,4.2) {Tabella Primaria};
				\draw[fill=blue!20, thick] (-2,3.7) rectangle (2,2.2);
				
				% Header
				\draw[fill=blue!40] (-2,3.7) -- (2,3.7) -- (2,3.4) -- (-2,3.4) -- cycle;
				\node[font=\tiny] at (-1.3,3.55) {\textbf{ID}};
				\node[font=\tiny] at (-0.3,3.55) {\textbf{Nome}};
				\node[font=\tiny] at (0.6,3.55) {\textbf{Ruolo}};
				\node[font=\tiny] at (1.5,3.55) {\textbf{Stipendio}};
				
				% Righe
				\node[font=\tiny] at (-1.3,3.1) {1};
				\node[font=\tiny] at (-0.3,3.1) {Mario};
				\node[font=\tiny] at (0.6,3.1) {Manager};
				\node[font=\tiny] at (1.5,3.1) {3000};
				
				\node[font=\tiny] at (-1.3,2.7) {2};
				\node[font=\tiny] at (-0.3,2.7) {Luca};
				\node[font=\tiny] at (0.6,2.7) {Operaio};
				\node[font=\tiny] at (1.5,2.7) {1500};
				
				\node[font=\tiny] at (-1.3,2.4) {3};
				\node[font=\tiny] at (-0.3,2.4) {Anna};
				\node[font=\tiny] at (0.6,2.4) {Manager};
				\node[font=\tiny] at (1.5,2.4) {3200};
				
				% Frecce bidirezionali
				\draw[<->, thick, green!60!black] (-2.5,3) -- (-2.5,1.3);
				\draw[<->, thick, orange!70] (2.5,3) -- (2.5,0.3);
				
				% Vista 1
				\node[font=\scriptsize\bfseries, green!60!black] at (-2.5,1.8) {Vista 1};
				\draw[fill=green!15, thick] (-4.5,1.5) rectangle (-0.5,0.5);
				\node[font=\tiny, align=center] at (-2.5,1.2) {\textbf{Solo Manager}};
				\node[font=\tiny] at (-3.3,0.9) {Mario};
				\node[font=\tiny] at (-1.7,0.9) {3000};
				\node[font=\tiny] at (-3.3,0.65) {Anna};
				\node[font=\tiny] at (-1.7,0.65) {3200};
				
				% Vista 2
				\node[font=\scriptsize\bfseries, orange!80!black] at (2.5,0.8) {Vista 2};
				\draw[fill=orange!15, thick] (0.5,0.5) rectangle (4.5,-0.3);
				\node[font=\tiny, align=center] at (2.5,0.2) {\textbf{Solo ID e Nome}};
				\node[font=\tiny] at (1.5,-0.05) {1 - Mario};
				\node[font=\tiny] at (3.5,-0.05) {2 - Luca};
				
			\end{tikzpicture}
		\end{center}
	\end{columns}
\end{frame}



\begin{frame}{I linguaggi per database relazionali}
	I linguaggi per database relazionali si basano sulla visione tabellare dei dati. 
	I comandi del linguaggio relazionale operano inoltre su gruppi di righe o sull'intera tabella, 
	anziche su una riga per volta: con una sola richiesta possono essere trattati o ritrovati molti 
	record e non un record per volta, come avviene nei tradizionali linguaggi di programmazione.
	Sono semplificate le operazioni per mettere in relazione tra loro tabelle diverse e per presentare 
	sul video o stampare i risultati delle interrogazioni in modo ordinato, facilitandone la lettura 
	e la comprensione.
	
	\vspace{0.3cm}
	\begin{center}
		\begin{tikzpicture}[scale=0.8]
			% Tabella Studenti
			\node[draw, rectangle, minimum width=3cm, minimum height=0.6cm, fill=blue!20] at (0,2) {\textbf{Studenti}};
			\node[draw, rectangle, minimum width=3cm, minimum height=0.5cm] at (0,1.4) {ID | Nome | Classe};
			\node[draw, rectangle, minimum width=3cm, minimum height=0.5cm] at (0,0.9) {1 | Mario | 5A};
			\node[draw, rectangle, minimum width=3cm, minimum height=0.5cm] at (0,0.4) {2 | Laura | 5B};
			
			% Tabella Voti
			\node[draw, rectangle, minimum width=3cm, minimum height=0.6cm, fill=green!20] at (5,2) {\textbf{Voti}};
			\node[draw, rectangle, minimum width=3cm, minimum height=0.5cm] at (5,1.4) {ID\_Stud | Materia | Voto};
			\node[draw, rectangle, minimum width=3cm, minimum height=0.5cm] at (5,0.9) {1 | Matematica | 8};
			\node[draw, rectangle, minimum width=3cm, minimum height=0.5cm] at (5,0.4) {1 | Italiano | 7};
			
			% Freccia di connessione
			\draw[->, thick, red] (1.5,1.15) -- (3.5,1.15) node[midway, above] {\small JOIN};
			
			% Query SQL
			\node[draw, rounded corners, fill=yellow!20, text width=7cm, align=center] at (2.5,-0.8) 
			{\small \texttt{SELECT * FROM Studenti WHERE Classe = '5A'}};
		\end{tikzpicture}
	\end{center}
\end{frame}


\begin{frame}{La gestione del database}
	\begin{columns}
		\column{0.55\textwidth}
		\textbf{2. La manipolazione e l'interrogazione sulla base di dati}
		\begin{itemize}
			\item Inserimento dei dati nel database e trattamento dei dati già registrati con operazioni di modifica o cancellazione.
			\item Interfaccia tra i programmi degli utenti (scritti con i tradizionali linguaggi di programmazione) e la base di dati, utilizzando le funzionalità del DBMS.
			\item Accesso ai dati del database attraverso interfacce grafiche e semplici comandi che facilitano l'utente non specialista.
		\end{itemize}
		
		\column{0.45\textwidth}
		\begin{center}
			\begin{tikzpicture}[scale=0.75]
				% Utenti
				\node[font=\tiny\bfseries] at (-1.5,4) {Programmatore};
				\draw[fill=blue!20, circle] (-1.5,3.5) circle (0.3);
				\draw[fill=blue!20] (-1.7,3.2) -- (-1.3,3.2) -- (-1.3,2.5) -- (-1.7,2.5) -- cycle;
				
				\node[font=\tiny\bfseries] at (1.5,4) {Utente Finale};
				\draw[fill=green!20, circle] (1.5,3.5) circle (0.3);
				\draw[fill=green!20] (1.3,3.2) -- (1.7,3.2) -- (1.7,2.5) -- (1.3,2.5) -- cycle;
				
				% Interfacce
				\draw[->, thick, blue] (-1.5,2.5) -- (-1.5,1.8);
				\node[font=\tiny, left] at (-1.5,2.15) {Codice};
				
				\draw[->, thick, green!60!black] (1.5,2.5) -- (1.5,1.8);
				\node[font=\tiny, right] at (1.5,2.15) {GUI};
				
				% DBMS
				\draw[fill=orange!20, rounded corners] (-2.5,1.8) rectangle (2.5,0.8);
				\node[font=\small\bfseries] at (0,1.5) {DBMS};
				\node[font=\tiny, align=center] at (0,1.1) {INSERT | UPDATE | DELETE\\SELECT};
				
				% Frecce verso DB
				\draw[->, thick] (-0.8,0.8) -- (-0.8,0.3);
				\draw[->, thick] (0,0.8) -- (0,0.3);
				\draw[->, thick] (0.8,0.8) -- (0.8,0.3);
				
				% Database
				\draw[fill=gray!30] (0,-0.2) ellipse (1.8 and 0.35);
				\draw[fill=gray!40] (-1.8,-0.2) -- (-1.8,-1) arc (180:360:1.8 and 0.35) -- (1.8,-0.2);
				\draw[fill=gray!30] (0,-1) ellipse (1.8 and 0.35);
				\node[font=\small\bfseries] at (0,-0.6) {DATABASE};
				
				% Operazioni
				\node[font=\tiny, orange!80!black] at (-1.3,0.5) {Insert};
				\node[font=\tiny, orange!80!black] at (0,0.5) {Update};
				\node[font=\tiny, orange!80!black] at (1.3,0.5) {Delete};
				
			\end{tikzpicture}
		\end{center}
	\end{columns}
\end{frame}

\begin{frame}{La gestione del database}
	\begin{columns}[T]
		
		\begin{column}{0.55\textwidth}
			\textbf{3. Il controllo dell'integrità dei dati}
			\begin{itemize}
				\item \textbf{Integrità dei dati}: in relazione ai valori ammissibili e alle interdipendenze tra attributi di tabelle differenti.
				\item \textbf{Integrità definite dall'utente}: vincoli specifici per un particolare database, derivanti da politiche aziendali o da norme legislative e fiscali.
			\end{itemize}
		\end{column}
		
		\begin{column}{0.45\textwidth}
			\begin{center}
				\begin{tikzpicture}[scale=0.7]
					% Tabella ORDINI
					\node[font=\scriptsize\bfseries] at (0,4.2) {Tabella ORDINI};
					\draw[fill=blue!15, thick] (-2,3.8) rectangle (2,2.8);
					\node[font=\tiny] at (-1.3,3.5) {\textbf{ID}};
					\node[font=\tiny] at (-0.3,3.5) {\textbf{ClienteID}};
					\node[font=\tiny] at (0.8,3.5) {\textbf{Importo}};
					\draw[fill=blue!10] (-2,3.3) rectangle (2,3.0);
					\node[font=\tiny] at (-1.3,3.15) {1};
					\node[font=\tiny] at (-0.3,3.15) {101};
					\node[font=\tiny] at (0.8,3.15) {500\,\euro};
					
					% Vincolo integrità referenziale
					\draw[->, thick, red, dashed] (-0.3,2.8) -- (-0.3,2.2);
					\node[font=\tiny, red, right] at (0.2,2.5) {FK};
					
					% Tabella CLIENTI
					\node[font=\scriptsize\bfseries, green!60!black] at (0,2) {Tabella CLIENTI};
					\draw[fill=green!15, thick] (-2,1.6) rectangle (2,0.6);
					\node[font=\tiny] at (-1.3,1.3) {\textbf{ID}};
					\node[font=\tiny] at (-0.3,1.3) {\textbf{Nome}};
					\node[font=\tiny] at (0.8,1.3) {\textbf{Credito}};
					\draw[fill=green!10] (-2,1.0) rectangle (2,0.7);
					\node[font=\tiny] at (-1.3,0.85) {101};
					\node[font=\tiny] at (-0.3,0.85) {Rossi};
					\node[font=\tiny] at (0.8,0.85) {1000\,\euro};
					
					% Vincoli
					\draw[fill=orange!15, rounded corners] (-2.2,0.2) rectangle (2.2,-0.9);
					\node[font=\tiny\bfseries, orange!80!black] at (0,0) {Vincoli di integrità};
					\node[font=\tiny, align=left] at (0,-0.35) {Importo $>$ 0};
					\node[font=\tiny, align=left] at (0,-0.6) {Importo $\leq$ Credito};
					\node[font=\tiny, align=left] at (0,-0.85) {ClienteID deve esistere (FK)};
					
					% Icona controllo (usare \ding per evitare Unicode)
					\draw[fill=red!20] (2.8,1.3) circle (0.4);
					\node[font=\small] at (2.8,1.3) {\ding{51}}; % \ding{51} = check
					
				\end{tikzpicture}
			\end{center}
		\end{column}
		
	\end{columns}
\end{frame}


\begin{frame}{La gestione del database}
\textbf{4. La sicurezza e la protezione}

\begin{itemize}
\item Garanzia di sicurezza dei dati contro i danni causati da malfunzionamenti di componenti hardware o software o da interventi dolosi.
\item Protezione dei dati da eventuali danneggiamenti per garantire l'integrità dei dati, offrendo anche la possibilità di attivare procedure di recovery in caso di perdita dei dati.
\item Autorizzazione degli utenti che accedono alla base di dati e protezione dei dati dagli accessi non autorizzati.
\item Controllo degli accessi al database in modo concorrente da parte di più utenti.
\end{itemize}
\end{frame}

\begin{frame}{La gestione del database}
	\begin{columns}[T]
		\begin{column}{0.55\textwidth}
			\begin{itemize}
				\item Un esempio di transazione è l'operazione di \textbf{trasferimento di fondi} tra conti correnti bancari.
				\item L'importo trasferito deve essere addebitato su un conto e accreditato sull'altro.
				\item Entrambe le operazioni devono essere completate affinché il trasferimento sia considerato effettuato.
				\item Non è accettabile che venga eseguita solo una delle due operazioni.
				\item Il supporto alle transazioni deve garantirne il corretto completamento anche in presenza di esecuzione concorrente.
			\end{itemize}
		\end{column}
		
		\begin{column}{0.45\textwidth}
			\begin{center}
				\begin{tikzpicture}[scale=0.75]
					
					% Stato iniziale
					\node[font=\scriptsize\bfseries] at (0,4.3) {Stato iniziale};
					
					\draw[fill=blue!20, rounded corners] (-2,4) rectangle (-0.3,3.4);
					\node[font=\tiny, align=center] at (-1.15,3.7) {Conto A\\1000\,\euro};
					
					\draw[fill=green!20, rounded corners] (0.3,4) rectangle (2,3.4);
					\node[font=\tiny, align=center] at (1.15,3.7) {Conto B\\500\,\euro};
					
					% Transazione
					\node[font=\scriptsize\bfseries, orange!80!black] at (0,3) {Transazione: 200\,\euro};
					
					\draw[fill=orange!15, rounded corners] (-2.2,2.7) rectangle (2.2,1.9);
					\node[font=\tiny] at (0,2.5) {BEGIN};
					\node[font=\tiny, red] at (0,2.25) {A = A - 200};
					\node[font=\tiny, green!60!black] at (0,2) {B = B + 200};
					
					% Atomicità
					\draw[<->, very thick, purple] (-2.2,2.5) -- (-2.2,2);
					\node[font=\tiny, purple, left, rotate=90] at (-2.4,2.25) {ATOMICA};
					
					% Stato finale corretto (commit)
					\node[font=\scriptsize\bfseries, green!60!black] at (-1.15,1.5) {Commit \checkmark};
					
					\draw[fill=blue!20, rounded corners] (-2,1.2) rectangle (-0.3,0.6);
					\node[font=\tiny, align=center] at (-1.15,0.9) {Conto A\\800\,\euro};
					
					\draw[fill=green!20, rounded corners] (0.3,1.2) rectangle (2,0.6);
					\node[font=\tiny, align=center] at (1.15,0.9) {Conto B\\700\,\euro};
					
					% Stato finale errato (rollback)
					\node[font=\scriptsize\bfseries, red] at (1.15,1.5) {Rollback \ding{55}};
					
					\draw[fill=red!10, rounded corners] (-2,0.3) rectangle (2,-0.3);
					\node[font=\tiny, red, align=center] at (0,0) {Stato inconsistente\\NON AMMESSO};
					
					% Concorrenza
					\draw[fill=yellow!20, rounded corners] (-2.2,-0.8) rectangle (2.2,-1.4);
					\node[font=\tiny, align=center] at (0,-1.1) {\textbf{Gestione della concorrenza}\\Più transazioni simultanee};
					
				\end{tikzpicture}
			\end{center}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{La gestione del database}
	\begin{columns}[T]
		\begin{column}{0.55\textwidth}
			\begin{itemize}
				\item Un esempio di transazione è l'operazione di \textbf{trasferimento di fondi} tra conti correnti bancari.
				\item L'importo trasferito deve essere addebitato su un conto e accreditato sull'altro.
				\item Entrambe le operazioni devono essere completate affinché il trasferimento sia considerato effettuato.
				\item Non è accettabile che venga eseguita solo una delle due operazioni.
				\item Il supporto alle transazioni deve garantirne il corretto completamento anche in presenza di esecuzione concorrente.
			\end{itemize}
		\end{column}
		
		\begin{column}{0.45\textwidth}
			\begin{center}
				\begin{tikzpicture}[scale=0.75]
					% Stato iniziale
					\node[font=\scriptsize\bfseries] at (0,4.3) {Stato iniziale};
					\draw[fill=blue!20, rounded corners] (-2,4) rectangle (-0.3,3.4);
					\node[font=\tiny, align=center] at (-1.15,3.7) {Conto A\\1000\,€};
					
					\draw[fill=green!20, rounded corners] (0.3,4) rectangle (2,3.4);
					\node[font=\tiny, align=center] at (1.15,3.7) {Conto B\\500\,€};
					
					% Transazione
					\node[font=\scriptsize\bfseries, orange!80!black] at (0,3) {Transazione: 200\,€};
					\draw[fill=orange!15, rounded corners] (-2.2,2.7) rectangle (2.2,1.9);
					\node[font=\tiny] at (0,2.5) {BEGIN};
					\node[font=\tiny, red] at (0,2.25) {A = A - 200};
					\node[font=\tiny, green!60!black] at (0,2) {B = B + 200};
					
					% Freccia atomicità
					\draw[<->, very thick, purple] (-2.2,2.5) -- (-2.2,2);
					\node[font=\tiny, purple, left, rotate=90] at (-2.4,2.25) {ATOMICA};
					
					% Stato finale corretto (commit)
					\node[font=\scriptsize\bfseries, green!60!black] at (-1.15,1.5) {Commit};
					\draw[fill=blue!20, rounded corners] (-2,1.2) rectangle (-0.3,0.6);
					\node[font=\tiny, align=center] at (-1.15,0.9) {Conto A\\800\,€};
					
					\draw[fill=green!20, rounded corners] (0.3,1.2) rectangle (2,0.6);
					\node[font=\tiny, align=center] at (1.15,0.9) {Conto B\\700\,€};
					
					% Stato finale errato (inconsistente)
					\node[font=\scriptsize\bfseries, red] at (1.15,1.5) {Rollback};
					\draw[fill=red!10, rounded corners] (-2,0.3) rectangle (2,-0.3);
					\node[font=\tiny, red, align=center] at (0,0) {Stato inconsistente\\NON AMMESSO};
					
					% Concorrenza
					\draw[fill=yellow!20, rounded corners] (-2.2,-0.8) rectangle (2.2,-1.4);
					\node[font=\tiny, align=center] at (0,-1.1) {\textbf{Gestione della concorrenza}\\Più transazioni simultanee};
					
				\end{tikzpicture}
			\end{center}
		\end{column}
	\end{columns}
\end{frame}



\begin{frame}{La gestione del database}
\textbf{6. L'ottimizzazione delle prestazioni}

\begin{itemize}
\item Uso delle tecniche che ottimizzano l'occupazione della memoria di massa e i tempi di accesso ai dati registrati sui supporti di memorizzazione.
\item Implementazione delle opportune strategie per ottimizzare le interrogazioni minimizzando i corrispondenti tempi di risposta o, più in generale, i costi dell'interrogazione.
\end{itemize}
\end{frame}

\begin{frame}{La gestione del database}
	\begin{itemize}
\item Per poter attuare questo ulteriore livello di ottimizzazione, il DBMS deve disporre di informazioni sulla numerosità dei record nelle tabelle e sulla distribuzione dei dati di uno specifico campo o di un dato indice: questi dati informativi costituiscono le \textbf{statistiche del database} o dati statistici gestiti dal DBMS.

\item L'esempio mostra come le statistiche possano essere usate dal modulo di ottimizzazione delle interrogazioni per costruirle nel modo più efficiente. Poiché la distribuzione dei dati in un campo o in un indice è un valore che cambia nel tempo (si pensi, per esempio, alla distribuzione degli studenti nei diversi dipartimenti), le statistiche sono un tipo di metadato dinamico gestito dal DBMS.

		
	\end{itemize}

\end{frame}

\begin{frame}{La gestione del database}
Un DBMS gestisce anche il \textbf{dizionario dei dati} (o catalogo del database), contenente informazioni su:

\begin{itemize}
\item nomi delle tabelle e delle colonne;
\item associazioni;
\item viste logiche;
\item vincoli di integrità;
\item utenti e proprietari;
\item autorizzazioni degli accessi.
\end{itemize}

Il dizionario contiene i \textbf{metadati}, cioè i dati che descrivono i dati contenuti nel database. Anche le informazioni del dizionario sono organizzate in modo relazionale, cioè come valori in tabelle. Gli utenti autorizzati possono quindi accedere alle informazioni del dizionario con le stesse modalità con le quali operano per ritrovare i dati nel database.
\end{frame}

% ========== I LINGUAGGI PER I DATABASE ==========
\begin{frame}{I linguaggi per i database}
Le prestazioni del DBMS vengono attivate dall'utente usando appositi comandi, che costituiscono a tutti gli effetti un linguaggio attraverso il quale l'utente può comunicare con il sistema di elaborazione che gestisce il database.

I comandi che il DBMS mette a disposizione possono essere classificati nelle seguenti categorie di linguaggi:

\textbf{Linguaggio per la descrizione dei dati}, delle tabelle e delle viste, delle associazioni tra tabelle, dei vincoli di integrità e dei controlli relativi alla sicurezza, detto \textbf{DDL} (Data Definition Language).
\end{frame}

\begin{frame}{I linguaggi per i database}
Il DDL rappresenta lo strumento attraverso il quale l'utente, facendo riferimento al proprio schema logico, ordina al DBMS la creazione della struttura fisica del database.

Il DDL possiede inoltre specifici comandi per definire i sottoschemi relativi alle applicazioni contenute nei programmi dei singoli utenti, oltre che per eliminare tabelle e viste già esistenti.

\textbf{Linguaggio per il trattamento (o manipolazione) dei dati} contenuti nel database, detto \textbf{DML} (Data Manipulation Language), che consente le usuali operazioni di accesso per inserimenti, modifiche o cancellazioni.
\end{frame}

\begin{frame}{I linguaggi per i database}
\textbf{Linguaggio per le interrogazioni} alla base di dati, detto \textbf{QL} (Query Language), che consente il ritrovamento dei dati che interessano, sulla base dei criteri di ricerca richiesti dall'utente.

Il linguaggio denominato DDL comprende anche la possibilità di generare in modo automatico, a partire dalle tabelle e dai loro attributi, le maschere video che servono a facilitare l'utente nell'inserimento, nella modifica e nella consultazione dei dati, e i prospetti di output per la rappresentazione ordinata e facilmente leggibile dei dati estratti dalla base di dati.
\end{frame}

\begin{frame}{I linguaggi per database relazionali}
Lo sviluppo e il raffinamento delle tecniche di gestione delle basi di dati hanno dato vita a linguaggi formati da comandi specifici, per consentire agli utenti un facile uso delle prestazioni del DBMS per basi di dati relazionali (detti RDBMS, cioè Relational DBMS).

Accanto alla possibilità di usare questi comandi, richiamandoli dall'interno di un programma scritto con i tradizionali linguaggi di programmazione (Cobol, C), è molto comune l'uso di linguaggi orientati alla gestione delle basi di dati, con caratteristiche di linguaggio a sé stanti.
\end{frame}

\begin{frame}{I linguaggi per database relazionali}
La diffusione del modello relazionale ha poi favorito l'uso prevalente di linguaggi non procedurali ma \textbf{dichiarativi}: in questo modo l'utente non ha la necessità di conoscere né le modalità con le quali le informazioni sono state fisicamente registrate, né i cammini per ritrovare le informazioni contenute nella base di dati.
\end{frame}





\begin{frame}{I linguaggi per database relazionali}
I linguaggi per database relazionali si basano sulla visione tabellare dei dati. I comandi del linguaggio relazionale operano inoltre su gruppi di righe o sull'intera tabella, anziché su una riga per volta: con una sola richiesta possono essere trattati o ritrovati molti record e non solo un record per volta, come avviene con i tradizionali linguaggi di programmazione.

Sono semplificate le operazioni per mettere in connessione tra loro tabelle diverse e per presentare sul video o stampare i risultati delle interrogazioni, ben impaginati, in modo da facilitarne la lettura e la comprensione.
\end{frame}




\begin{frame}{I linguaggi per database relazionali}
	I linguaggi per database relazionali si basano sulla visione tabellare dei dati. I comandi del linguaggio relazionale operano inoltre su gruppi di righe o sull'intera tabella, anziché su una riga per volta: con una sola richiesta possono essere trattati o ritrovati molti record e non solo un record per volta, come avviene con i tradizionali linguaggi di programmazione.
	Sono semplificate le operazioni per mettere in connessione tra loro tabelle diverse e per presentare sul video o stampare i risultati delle interrogazioni, ben impaginati, in modo da facilitarne la lettura e la comprensione.
	
	\vspace{0.3cm}
	\begin{center}
		\begin{tikzpicture}[scale=0.8]
			% Tabella Studenti
			\node[draw, rectangle, minimum width=3cm, minimum height=0.6cm, fill=blue!20] at (0,2) {\textbf{Studenti}};
			\node[draw, rectangle, minimum width=3cm, minimum height=0.5cm] at (0,1.4) {ID | Nome | Classe};
			\node[draw, rectangle, minimum width=3cm, minimum height=0.5cm] at (0,0.9) {1 | Mario | 5A};
			\node[draw, rectangle, minimum width=3cm, minimum height=0.5cm] at (0,0.4) {2 | Laura | 5B};
			
			% Tabella Voti
			\node[draw, rectangle, minimum width=3cm, minimum height=0.6cm, fill=green!20] at (5,2) {\textbf{Voti}};
			\node[draw, rectangle, minimum width=3cm, minimum height=0.5cm] at (5,1.4) {ID\_Stud | Materia | Voto};
			\node[draw, rectangle, minimum width=3cm, minimum height=0.5cm] at (5,0.9) {1 | Matematica | 8};
			\node[draw, rectangle, minimum width=3cm, minimum height=0.5cm] at (5,0.4) {1 | Italiano | 7};
			
			% Freccia di connessione
			\draw[->, thick, red] (1.5,1.15) -- (3.5,1.15) node[midway, above] {\small JOIN};
			
			% Query SQL
			\node[draw, rounded corners, fill=yellow!20, text width=7cm, align=center] at (2.5,-0.8) 
			{\small \texttt{SELECT * FROM Studenti WHERE Classe = '5A'}};
		\end{tikzpicture}
	\end{center}
\end{frame}





\begin{frame}{I linguaggi per database relazionali}
Nei software DBMS, soprattutto nelle implementazioni di prodotti su personal computer, sono disponibili interfacce utente, con le quali si può interagire usando la lingua nazionale, che permettono di selezionare i comandi del linguaggio attraverso menu, sottomenu e il puntamento a icone sul video, con le modalità caratteristiche di un'interfaccia grafica.

Sono inoltre disponibili messaggi di aiuto, che possono essere richiamati sul video in modo contestuale, cioè nel momento in cui serve una breve spiegazione sul tipo di operazione che si vuole attivare.
\end{frame}

% ========== GLI UTENTI ==========
\begin{frame}{Gli utenti}
Un database viene utilizzato da persone diverse, per funzioni e per applicazioni diverse.

\textbf{1. L'Amministratore della Base di Dati (DBA, DataBase Administrator)} con i seguenti compiti:

\begin{itemize}
\item implementazione del modello logico del database nel sistema di elaborazione sui supporti fisici delle memorie di massa;
\item gestione e trattamento dei dati (controllo di inserimenti, modifiche, cancellazioni);
\item autorizzazione degli accessi;
\item definizione delle viste per accessi parziali di utenti alla base di dati;
\item controllo dei programmi applicativi che richiedono l'uso del database;
\end{itemize}
\end{frame}

\begin{frame}{Gli utenti}
\begin{itemize}
\item manutenzione del database nel tempo, in termini di efficienza e di ottimizzazione delle risorse;
\item controllo sugli interventi di recupero, nel caso di cattivi funzionamenti, e sulle copie di salvataggio periodiche;
\item controllo della disponibilità degli spazi su memoria di massa.
\end{itemize}

Il DBA utilizza, per svolgere le sue funzioni, le prestazioni e i linguaggi del DBMS e collabora con le altre figure (sistemista, analista, responsabile dello sviluppo software, programmatore) nelle diverse fasi: progettazione del database, costruzione delle applicazioni, traduzione dello schema del database nel modello fisico da creare su memoria di massa, manutenzione dei dati nel tempo.
\end{frame}

\begin{frame}{Gli utenti}
\textbf{2. I programmatori}, che intendono utilizzare per le loro applicazioni i dati organizzati in un database, sfruttano un linguaggio DML, oppure comandi che sono un'estensione dei tradizionali linguaggi di programmazione, oppure un linguaggio specifico per basi di dati.

In ogni caso il programmatore deve agire sotto il controllo del gruppo di progetto e di produzione del software applicativo a cui partecipa anche l'Amministratore del database.
\end{frame}

\begin{frame}{Gli utenti}
\textbf{3. Gli utenti finali} possono accedere alla base di dati attraverso i comandi di un linguaggio di interrogazione, di un linguaggio QBE, oppure (per utenti finali ancora meno esperti) attraverso interfacce software che presentano sul video finestre, menu e icone.
\end{frame}

% ========== LE TRANSAZIONI ==========
\section{Le transazioni}
\begin{frame}
\begin{center}
{\LARGE \textbf{Le transazioni}}
\end{center}
\end{frame}

\begin{frame}{Le proprietà acide delle transazioni}
	\begin{itemize}
\item L'importo trasferito deve essere tolto da un conto e aggiunto all'altro. Entrambe le operazioni devono essere eseguite per poter affermare di avere concluso il trasferimento e non è tollerabile che venga eseguita una sola delle due operazioni.
\item Ne segue che il sistema di gestione delle transazioni deve intervenire per effettuare un \textbf{rollback} automatico nel caso che, per una qualsiasi ragione, una delle due operazioni di aggiornamento della base di dati non vada a buon fine.

\item Questo comportamento caratterizza un'importante proprietà delle transazioni e prende il nome di \textbf{atomicità}. Essa è una delle cosiddette proprietà acide delle transazioni, dall'acronimo inglese \textbf{ACID} (Atomicity, Consistency, Isolation, Durability).

	\end{itemize}


\end{frame}

\begin{frame}{Le proprietà acide delle transazioni}
\begin{itemize}
\item \textbf{Atomicità}: una transazione è un'entità atomica indivisibile. È compito del sistema di gestione della sicurezza garantire l'atomicità e riuscire a ripristinare la situazione preesistente quando necessario;
\item \textbf{Consistenza}: le transazioni non devono violare i vincoli di integrità dei dati. La consistenza è gestita dal DBMS con procedure opportune;
\item \textbf{Isolamento}: gli effetti di una transazione devono essere indipendenti da quello di tutte le altre transazioni eseguite in concorrenza. L'isolamento è gestito dal controllore della concorrenza.
\end{itemize}
\end{frame}

\begin{frame}{Le proprietà acide delle transazioni}
\begin{itemize}
\item \textbf{Persistenza}: le informazioni in un database devono essere memorizzate in modo persistente, cioè per sempre. Gli effetti di una transazione eseguita con esito positivo (dopo l'esecuzione di un comando commit) devono essere memorizzati permanentemente nel database a cura del sistema di gestione della sicurezza e del ripristino dei dati.
\end{itemize}
\end{frame}

% Frame finale
\begin{frame}
\begin{center}
{\LARGE \textbf{Grazie per l'attenzione!}}
\end{center}
\end{frame}

\end{document}
