\documentclass{beamer}
\usetheme{Madrid}

\title{Password hashing in PHP}
\subtitle{Salt, costo computazionale e algoritmi}
\author{Prof. Fedeli Massimo - Tutti i diritti riservati}
\date{}

\begin{document}
	
	\begin{frame}
		\titlepage
	\end{frame}
	
	\begin{frame}{Perché usare una salt}
		La \textbf{salt} è una stringa casuale aggiunta alla password prima del calcolo dell’hash.
		\vspace{0.3cm}
		
		Serve a:
		\begin{itemize}
			\item impedire l’uso di rainbow table
			\item evitare hash identici per password identiche
			\item rendere gli attacchi offline più costosi
		\end{itemize}
		
		Ogni password deve avere una salt diversa.
	\end{frame}
	
	\begin{frame}{\texttt{password\_hash}: cosa produce}
		La funzione \texttt{password\_hash} restituisce una stringa strutturata che contiene:
		\begin{itemize}
			\item algoritmo utilizzato
			\item parametri di costo
			\item salt generata automaticamente
			\item hash finale
		\end{itemize}
		
		Tutte queste informazioni sono incorporate nell’hash stesso.
	\end{frame}
	
	\begin{frame}{Come funziona \texttt{password\_verify}}
		Quando si usa \texttt{password\_verify(password, hash)}:
		\begin{enumerate}
			\item PHP legge algoritmo e parametri dall’hash
			\item estrae la salt contenuta nell’hash
			\item ricalcola l’hash con la password inserita
			\item confronta i risultati in modo sicuro
		\end{enumerate}
		
		La verifica funziona anche con salt diverse per ogni password.
	\end{frame}
	
	\begin{frame}{Il concetto di costo computazionale}
		Il \textbf{costo} indica quanto è oneroso calcolare l’hash.
		\vspace{0.3cm}
		
		Aumentare il costo significa:
		\begin{itemize}
			\item rallentare il login (di pochi millisecondi)
			\item rallentare enormemente gli attacchi a forza bruta
		\end{itemize}
		
		Il costo è un compromesso tra sicurezza e prestazioni.
	\end{frame}
	
	\begin{frame}{Costo negli algoritmi}
		Esempi:
		\begin{itemize}
			\item \textbf{bcrypt}: costo espresso come numero di iterazioni (cost)
			\item \textbf{Argon2}: costo basato su tempo, memoria e parallelismo
		\end{itemize}
		
		Il costo è memorizzato nell’hash e usato automaticamente in fase di verifica.
	\end{frame}
	
	\begin{frame}{Algoritmi disponibili in \texttt{password\_hash}}
		PHP supporta diversi algoritmi:
		\begin{itemize}
			\item \textbf{PASSWORD\_BCRYPT}
			\item \textbf{PASSWORD\_ARGON2I}
			\item \textbf{PASSWORD\_ARGON2ID}
			\item \textbf{PASSWORD\_DEFAULT}
		\end{itemize}
		
		\texttt{PASSWORD\_DEFAULT} seleziona l’algoritmo migliore disponibile nella versione di PHP.
	\end{frame}
	
	\begin{frame}{Confronto tra gli algoritmi}
		\begin{itemize}
			\item \textbf{bcrypt}
			\begin{itemize}
				\item molto diffuso e collaudato
				\item resistente, ma non memory-hard
			\end{itemize}
			\item \textbf{Argon2}
			\begin{itemize}
				\item vincitore del Password Hashing Competition
				\item progettato per contrastare GPU e ASIC
			\end{itemize}
		\end{itemize}
		
		Argon2id è oggi la scelta consigliata.
	\end{frame}
	
	\begin{frame}{Perché non gestire salt e costo manualmente}
		Gestire manualmente questi aspetti:
		\begin{itemize}
			\item aumenta il rischio di errori
			\item non migliora la sicurezza
			\item riduce la manutenibilità
		\end{itemize}
		
		Le funzioni di PHP sono progettate per un uso sicuro di default.
	\end{frame}
	
	\begin{frame}{Conclusione}
		\begin{itemize}
			\item ogni password ha una salt unica
			\item l’hash contiene algoritmo, costo e salt
			\item \texttt{password\_verify} ricostruisce il processo automaticamente
			\item il costo rende gli attacchi computazionalmente proibitivi
		\end{itemize}
		
		In sicurezza, la semplicità controllata è una virtù.
	\end{frame}
	
\end{document}
